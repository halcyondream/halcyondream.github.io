<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>TryHackMe DevSecOps CTF walkthrough | halcyondream</title>
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="TryHackMe DevSecOps CTF walkthrough" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Overview of “Mother’s Secrets”" />
<meta property="og:description" content="Overview of “Mother’s Secrets”" />
<link rel="canonical" href="http://localhost:4000/2024/02/18/thm-dso-walkthrough.html" />
<meta property="og:url" content="http://localhost:4000/2024/02/18/thm-dso-walkthrough.html" />
<meta property="og:site_name" content="halcyondream" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-02-18T00:00:00-05:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="TryHackMe DevSecOps CTF walkthrough" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-02-18T00:00:00-05:00","datePublished":"2024-02-18T00:00:00-05:00","description":"Overview of “Mother’s Secrets”","headline":"TryHackMe DevSecOps CTF walkthrough","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2024/02/18/thm-dso-walkthrough.html"},"url":"http://localhost:4000/2024/02/18/thm-dso-walkthrough.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="halcyondream" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">halcyondream</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">TryHackMe DevSecOps CTF walkthrough</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2024-02-18T00:00:00-05:00" itemprop="datePublished">Feb 18, 2024
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h1 id="overview-of-mothers-secrets">Overview of “Mother’s Secrets”</h1>

<p>“Mother’s secrets” is a web pentest challenge. It is an unguided challenge and therefore resembles a “real” CTF. This writeup covers my own methodology, not just for finding the flags, but for testing the system as though this were a real-world engagement.</p>

<p>Much of the content is redacted or not included, as that would take the fun out of doing the challenge yourself. You are encouraged to use this as a guide to develop your own approach, not as a cheat-sheet for the answers. (Incidentally, as you will see later, you can find all of the referenced file content online, available to the public, even without a THM subscription.)</p>

<p>Also, shoutout to the <em>Alien</em> theme and references.</p>

<p>Without even reading the challenge description, keep in mind that this is a <em>DevSecOps</em> exercise. As you build a threat model of this application, keep in mind the attack surface:</p>

<ul>
  <li>Secrets management (or lack thereof)</li>
  <li>Source-code management</li>
  <li>Build and deploy configuration</li>
  <li>System environment configuration</li>
  <li>Application stack and configuration</li>
  <li>Insecure coding practices</li>
  <li>Identity and Access Management</li>
</ul>

<p>Right off the bat, the last two will stand out in the “task files,” which represent either a gray-box assessment, or an instance of leaked source code.</p>

<h1 id="methodology">Methodology</h1>

<p>First, download the “task files.” This is a single, flat file which contains code for two routes: <code class="language-plaintext highlighter-rouge">yaml.js</code> and <code class="language-plaintext highlighter-rouge">nostromo.js</code>.</p>

<p>First, inspect <code class="language-plaintext highlighter-rouge">yaml.js</code>:</p>
<ul>
  <li>The <em>isYaml</em> arrow function only performs validation on the suffix of a given filename (ends with <code class="language-plaintext highlighter-rouge">.yaml</code>). In the real world, this would not be considered a “robust” solution for file validation. However, we will see later that this is a non-issue for our goals as an attacker.</li>
  <li>The route at <code class="language-plaintext highlighter-rouge">/</code> accepts a POST request with a JSON object containing a property called <code class="language-plaintext highlighter-rouge">file_path</code>. It validates whether the file ends with <code class="language-plaintext highlighter-rouge">.yaml</code> and then validates whether the file exists. In short, if you provide a real YAML file path, the contents of that file are returned.</li>
  <li>The <code class="language-plaintext highlighter-rouge">file_path</code> string is unsafely inserted into <code class="language-plaintext highlighter-rouge">./public/${file_path}</code>. This can enable path traversal by the time it reaches the call to <em>fs.readFile</em>. Informationally, take note that this will target a folder called <em>public/</em> which exists in the same directory as <code class="language-plaintext highlighter-rouge">yaml.js</code>.</li>
  <li>Note that <em>fs.readFile</em> will return the contents of a file only. It will not return a directory listing. If the file does not exist, it will raise the error condition in the callback.</li>
  <li>Finally, there is an interesting import of <code class="language-plaintext highlighter-rouge">../websocket.js</code>. The business logic here seems trivial, but the import itself is of interest.</li>
</ul>

<p>Now, inspect <code class="language-plaintext highlighter-rouge">nostromo.js</code>:</p>
<ul>
  <li>The POST-based <code class="language-plaintext highlighter-rouge">/nostromo</code> route is nearly identical in behavior to the <code class="language-plaintext highlighter-rouge">/yaml</code> route seen earlier; this includes the path-traversal vulnerability. There are two major differences, however: no filename validation, and logic that sets the global <code class="language-plaintext highlighter-rouge">isNostromoAuthenticate</code> variable to <em>true</em>. In short, if you give this route the path to <em>any</em> file that exists, it will return the contents of that file unconditionally.</li>
  <li>Likewise <code class="language-plaintext highlighter-rouge">/nostromo/mother</code> POST route is nearly identical to the <code class="language-plaintext highlighter-rouge">/nostromo</code> route, but with two major differences. The first is that, in order to return the contents, two global variables must be <em>true</em>: <em>isNostromoAuthenticate</em> and <em>isYamlAuthenticate</em>. (The task file <code class="language-plaintext highlighter-rouge">yaml.js</code> does not include logic for <em>isYamlAuthenticate</em>, so it’s possible that some or all of the source code is outdated.) The second major difference is that it reads files from a path called <em>mother/</em>, which is important to note as we build an understanding of the underlying structure.</li>
  <li>This imports <code class="language-plaintext highlighter-rouge">./yaml.js</code> from the same directory. In the application, we could expect both files to exist in the same place, although it is not yet clear what the folder is named.</li>
  <li>This also imports code from <code class="language-plaintext highlighter-rouge">../websocket.js</code>. Note that, in both routes’ code, this exists one directory up.</li>
  <li>Finally, the commented-out import statement implies a folder at <code class="language-plaintext highlighter-rouge">../../mothers_secret_challenge</code>, which contains a file called <code class="language-plaintext highlighter-rouge">../websocket.js</code>. If you follow the relative paths, you’ll notice that this could be the name of the project folder, as the location of <code class="language-plaintext highlighter-rouge">websocket.js</code> matches with this path.</li>
</ul>

<p>Based on static analysis, we can infer the following:</p>
<ul>
  <li>The project is likely based on NodeJS.</li>
  <li>A rough outline of the project structure is evident.</li>
  <li>The <code class="language-plaintext highlighter-rouge">/nostromo</code> route is the easiest to attack in order to achieve path traversal, and may prove the most valuable.</li>
  <li>The <code class="language-plaintext highlighter-rouge">/yaml</code> route can be exploited only if we know the location of a YAML file on the system.</li>
  <li>The <code class="language-plaintext highlighter-rouge">/nostromo/mother</code> route can be exploited only after <code class="language-plaintext highlighter-rouge">/yaml</code> and <code class="language-plaintext highlighter-rouge">/nostromo</code> are successfully executed.</li>
</ul>

<p>We also have a rough idea of the project structure:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mothers_secret_challenge/
- websocket.js
- &lt;folder&gt;/
	- yaml.js
	- nostromo.js
	- public/
	- mother/
</code></pre></div></div>

<p>And some relevant technologies:</p>

<ul>
  <li><a href="https://www.npmjs.com/package/js-yaml">js-yaml</a>: Using <em>yaml.load</em> to load a <a href="https://snyk.io/advisor/npm-package/js-yaml/functions/js-yaml.load">YAML file</a></li>
  <li><a href="https://www.npmjs.com/package/express">express</a>: Using <em>Router.post</em> for <a href="https://expressjs.com/en/guide/routing.html">POST-based routes</a></li>
  <li><a href="https://nodejs.org/api/fs.html">fs</a>: Using <em>fs.readFile</em> to <a href="https://nodejs.org/dist/latest-v6.x/docs/api/fs.html#fs_fs_readfile_file_options_callback">read the contents of any file</a></li>
</ul>

<p>With this in mind, let’s visit the site at <code class="language-plaintext highlighter-rouge">http://IP_ADDRESS</code>. The home page is a single HTML file, which imports some JS files. Informationally, we will note the presence of <code class="language-plaintext highlighter-rouge">index.min.js</code>, but will safe static analysis for later because minified JS is a pain to read.</p>

<p>Aside from that, the frontend functionality is pretty limited. You can use the UP and DOWN arrows on your keyboard to navigate to different text panels. At this stage, the content does not reveal much, so we can save this for later.</p>

<p>Let’s try to understand the API. The frontend does not reveal anything about where the routes exist, so you will need to test the route names with some <a href="https://gist.github.com/yassineaboukir/8e12adefbd505ef704674ad6ad48743d">common API naming conventions</a>. In this case, here are the locations:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">http://IP_ADDRESS/yaml</code></li>
  <li><code class="language-plaintext highlighter-rouge">http://IP_ADDRESS/api/nostromo</code></li>
  <li><code class="language-plaintext highlighter-rouge">http://IP_ADDRESS/api/nostromo/mother</code></li>
</ul>

<p>Make sure you are using POST requests to access these. Otherwise, you will get a generic message about the “wrong route.”</p>

<p>Earlier, we determined that <code class="language-plaintext highlighter-rouge">/nostromo</code> is the most exploitable route. First, try to exploit the Path Traversal vulnerability identified during static analysis. Let’s try to fetch the contents of <code class="language-plaintext highlighter-rouge">../nostromo.js</code> because we know where this file lives: one directory above the <em>public/</em> folder:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>POST /nostromo HTTP/1.1
Host: http://IP_ADDRESS
Content-Type: application/json
...

{
  "file_path": "../nostromo.js"
}
</code></pre></div></div>

<p>The contents of this file, which we observed from the task file, is returned. We can infer two things here: that path traversal is achievable, and that file contents are returned as-is.</p>

<p>Next, let’s also see if some common NodeJS artifacts exist. Try to return the <code class="language-plaintext highlighter-rouge">package.json</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>POST /nostromo HTTP/1.1
Host: http://IP_ADDRESS
Content-Type: application/json
...

{
  "file_path": "../package.json"
}
</code></pre></div></div>

<p>This returns the following:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
  "name": "mother-secret",
  "version": "1.0.0",
  "description": "",
  "main": "server.js",
  "type": "module",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "compression": "^1.7.4",
    "express": "^4.18.2",
    "js-yaml": "^4.1.0",
    "nodemon": "^2.0.22",
    "socket.io": "^4.7.0"
  }
}
</code></pre></div></div>

<p>The contents confirm that the project is in fact NodeJS based. We can also see the imports from the task files in this package structure.</p>

<p>Based on the <em>scripts</em>, it looks like the main logic lives in <code class="language-plaintext highlighter-rouge">server.js</code>. Let’s inspect that file:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>POST /nostromo HTTP/1.1
Host: http://IP_ADDRESS
Content-Type: application/json
...

{
  "file_path": "../server.json"
}
</code></pre></div></div>

<p>The contents:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">express</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">express</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">fileURLToPath</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">url</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">compression</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">compression</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">path</span><span class="p">,</span> <span class="p">{</span> <span class="nx">dirname</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">path</span><span class="dl">"</span><span class="p">;</span>
<span class="c1">// import {routeNostromo} from "./routes/nostromo.js";</span>
<span class="k">import</span> <span class="nx">routeNostromo</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./routes/nostromo.js</span><span class="dl">"</span><span class="p">;</span>

<span class="k">import</span> <span class="nx">routeYaml</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./routes/yaml.js</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">http</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">http</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">attachWebSocket</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./websocket.js</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">app</span> <span class="o">=</span> <span class="nx">express</span><span class="p">();</span>
<span class="kd">const</span> <span class="nx">server</span> <span class="o">=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">createServer</span><span class="p">(</span><span class="nx">app</span><span class="p">);</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">__filename</span> <span class="o">=</span> <span class="nx">fileURLToPath</span><span class="p">(</span><span class="k">import</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">url</span><span class="p">);</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">__dirname</span> <span class="o">=</span> <span class="nx">dirname</span><span class="p">(</span><span class="nx">__filename</span><span class="p">);</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">express</span><span class="p">.</span><span class="kd">static</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">__dirname</span><span class="p">}</span><span class="s2">/public/`</span><span class="p">));</span>
<span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">express</span><span class="p">.</span><span class="nx">json</span><span class="p">({</span> <span class="na">limit</span><span class="p">:</span> <span class="dl">"</span><span class="s2">10kb</span><span class="dl">"</span> <span class="p">}));</span>
<span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">compression</span><span class="p">());</span>

<span class="c1">// route middleware</span>
<span class="nx">app</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="dl">"</span><span class="s2">/</span><span class="dl">"</span><span class="p">,</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">filePath</span> <span class="o">=</span> <span class="nx">path</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="nx">__dirname</span><span class="p">,</span> <span class="dl">"</span><span class="s2">views</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">index.html</span><span class="dl">"</span><span class="p">);</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">sendFile</span><span class="p">(</span><span class="nx">filePath</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<p>In itself, this reveals new information about the package structure:</p>
<ul>
  <li>A folder called <em>views</em>, which contains <code class="language-plaintext highlighter-rouge">index.html</code>, the frontend application</li>
  <li>Since <code class="language-plaintext highlighter-rouge">index.html</code> imports <code class="language-plaintext highlighter-rouge">index.min.js</code> from the same directory, we can also infer that it too lives in <em>views/</em></li>
  <li><code class="language-plaintext highlighter-rouge">nostromo.js</code> and <code class="language-plaintext highlighter-rouge">yaml.js</code> both live in a folder called <em>routes</em></li>
  <li><code class="language-plaintext highlighter-rouge">websocket.js</code> lives in the top-level directory, alongside <code class="language-plaintext highlighter-rouge">package.json</code> and the major folders in use</li>
</ul>

<p>Let’s update our package structure map:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mothers_secret_challenge/
- routes/
	- nostromo.js
	- yaml.js
- websocket.js
- views/
	- index.html
	- index.min.js?
- public/
	- ?
- mother/
	- ?
- package.json
</code></pre></div></div>

<p>At this point, you can also exploit path traversal to probe for information about the underlying filesystem:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">../../../../etc/passwd</code> proves that we are on a Linux or Unix-like system, and reveals a few interesting artifacts. First, the existence of the <code class="language-plaintext highlighter-rouge">ec2-instance-connect</code> user implies that the server is an AWS EC2 instance. Second, the existence of the <code class="language-plaintext highlighter-rouge">ubuntu</code> user implies that this is an Ubuntu instance. Finally, the <code class="language-plaintext highlighter-rouge">www-data</code> user’s home path of <code class="language-plaintext highlighter-rouge">/var/www</code> implies that our project lives somewhere in <em>/var/www/</em>, a hunch that is reinforced by the minimum levels of directories needed to traverse to <em>/etc/passwd</em> from the <code class="language-plaintext highlighter-rouge">/nostromo</code> route. So, this Node project likely exists at <code class="language-plaintext highlighter-rouge">/var/www/mothers_secret_challenge</code>, a common deployment pattern in Linux-based systems.</li>
  <li>The Ubuntu and Root users both have an <code class="language-plaintext highlighter-rouge">authorized_hosts</code> file, which implies that the capability to SSH into this box is feasible. (This is also revealed by a quick Nmap scan against the IP address.) However, no private SSH keys exist in common locations, so the capability to SSH into them is limited. Further, if you try to ssh in using the <code class="language-plaintext highlighter-rouge">ubuntu</code> user, you are denied with a public-key error, which implies that password-based authentication is disabled. Although SSH would be an easy way to pivot around the system, it may prove infeasible for this challenge.</li>
  <li>Because this is an EC2 instance, we can speculate that at least one YAML configuration file exists, which we can then use in the <code class="language-plaintext highlighter-rouge">/yaml</code> route to set <code class="language-plaintext highlighter-rouge">isYamlAuthenticated</code> to <em>true</em>. The hunch here is predicated by the fact that <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html#user-data-cloud-init">EC2 cloud-init files</a> are often written in YAML format, and likely with a <code class="language-plaintext highlighter-rouge">.yaml</code> extension. In this system, inspecting <code class="language-plaintext highlighter-rouge">../../../../var/log/cloud-init.log</code> at line 361 will reveal the existence of <code class="language-plaintext highlighter-rouge">/etc/netplan/50-cloud-init.yaml</code>, whose relative path to <em>routes/</em> can be used in the <code class="language-plaintext highlighter-rouge">/yaml</code> route to authenticate.</li>
</ul>

<p>If you follow the methodology thus far, you will successfully authenticate to <code class="language-plaintext highlighter-rouge">/nostromo/mother</code>, where you will need to dig for the secret file. The instructions imply the existence of <code class="language-plaintext highlighter-rouge">secret.txt</code>, and it may be worth checking that file at this time. (This is actually what I did the first time, and got mother’s secrets before the other flags.)</p>

<p>However, since this seems like a poorly deployed Node package, it is also worth looking for other components that are commonly used with application projects.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Dockerfile</code> and <code class="language-plaintext highlighter-rouge">docker-compose.yml</code>, <a href="https://forums.docker.com/t/docker-compose-yml-or-dockerfile/133015">Docker configurations</a>, which may reveal build information and hardcoded secrets</li>
  <li><code class="language-plaintext highlighter-rouge">.env</code> file, which <a href="https://nodejs.org/en/learn/command-line/how-to-read-environment-variables-from-nodejs">contains environment variables</a> and may include hardcoded secrets</li>
  <li><code class="language-plaintext highlighter-rouge">.git</code> folder and <code class="language-plaintext highlighter-rouge">.gitignore</code>, <a href="https://www.git-scm.com/docs/gitrepository-layout">artifacts from the Git version-control system</a>, which may reveal the existence of specific files in the project</li>
</ul>

<p>These configurations often exist in the top-level directory of a project, so try to enumerate them one path up from <em>routes/</em>:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">../.env.json</code>: <em>Error</em></li>
  <li><code class="language-plaintext highlighter-rouge">../Dockerfile</code>: <em>Error</em></li>
  <li><code class="language-plaintext highlighter-rouge">../.gitignore</code>: <em>Found!</em></li>
</ul>

<p>Since <code class="language-plaintext highlighter-rouge">.gitignore</code> is found, we can try to enumerate the contents of <code class="language-plaintext highlighter-rouge">.git</code> to learn more about the contents of the project. The only <em>potential</em> caveat is that, if these contents were not committed to Git, they will not appear in the <code class="language-plaintext highlighter-rouge">.git</code> artifacts. However, since this is a DevSecOps path, it is reasonable to speculate whether VCS triggered the build and deploy process; if so, the Git contents should reveal everything in the project.</p>

<p>The Git project structure is fairly predictable, and you are welcome to leverage the <code class="language-plaintext highlighter-rouge">/nostromo</code> route to pick any of them. For discovery purposes, two files are of particular interest:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">.git/config</code>, a flat text file which includes metadata about the project</li>
  <li><code class="language-plaintext highlighter-rouge">.git/index</code>, a binary file which contains strings, notably the paths to files in the project</li>
</ul>

<p>Let’s try to inspect the config file:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>POST /nostromo HTTP/1.1
Host: http://IP_ADDRESS
Content-Type: application/json
...

{
  "file_path": "../.git/config"
}
</code></pre></div></div>

<p>The contents return, which imply that Git VCS is in use:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HTTP/1.1 200 OK
X-Powered-By: Express
Content-Type: text/html; charset=utf-8
Content-Length: 276
ETag: W/"114-l3m2M+q7EwbIe2cuUUG/ULGbdA8"
Vary: Accept-Encoding
Date: Wed, 05 Jun 2024 20:04:56 GMT
Connection: close

[core]
	repositoryformatversion = 0
	filemode = true
	bare = false
	logallrefupdates = true
[remote "origin"]
	url = https://github.com/melmols/mothers_secret_challenge.git
	fetch = +refs/heads/*:refs/remotes/origin/*
[branch "main"]
	remote = origin
	merge = refs/heads/main
</code></pre></div></div>

<p>At this point, I need to stop and make two major call-outs:</p>
<ul>
  <li>Because <code class="language-plaintext highlighter-rouge">config</code> exists, it is reasonable to continue your black-box assessment by analyzing the <code class="language-plaintext highlighter-rouge">index</code> file. We will do this in a moment. However…</li>
  <li>If you inspect the URL, you should notice the cleartext path to a Git repository, https://github.com/melmols/mothers_secret_challenge.git</li>
</ul>

<p>Remove the <code class="language-plaintext highlighter-rouge">.git</code> suffix from that URL and open it in your browser. The entire project is hosted on a public Github repository. At this point, you can complete the entire CTF by inspecting those files, as all the secrets exist there in clear text.</p>

<p>This is not a “normal” find for a CTF. However, this is a <em>DevSecOps learning path</em>; likely, the author of this challenge wants you to understand the importance of hardening your entire CI/CD, including <em>access to the entire repository</em>, <em>especially</em> when that repository contains hardcoded secrets (flags).</p>

<p><em>Note: The user <code class="language-plaintext highlighter-rouge">melmols</code>, who maintains this repository, also appears in /home/ubuntu/.ssh/authorized_hosts. Based on previous challenges in this learning path, it is possible that they used SSH to deploy the application to this instance.</em></p>

<p>You are welcome, and perhaps encouraged, to inspect this repository inside and out, as it may will certainly help you complete the CTF more quickly. However, I feel like this is taking the easy way out, so I will continue with testing the system as a black-grey box.</p>

<p>Anyway, let’s pretend that the devs have secured the project repository, but deployed the <code class="language-plaintext highlighter-rouge">.git</code> folder. This is not a good practice. To demonstrate why, lest’s talk about the <code class="language-plaintext highlighter-rouge">index</code> file.</p>

<p>From the <a href="https://git-scm.com/docs/index-format">Git docs</a>, you can learn all about the structure of this binary file. Of importance, let’s review the Index Entries:</p>

<blockquote>
  <p>An index entry typically represents a file.</p>
</blockquote>

<p>To inspect the <em>index</em> file, you could use something like <a href="https://www.git-scm.com/docs/git-cat-file"><em>git cat-file</em></a>. However, this would only work if we had access to the source repository (we’re still pretending that we don’t), or if command injection/shell access were achieveable on the server. Since neither of these conditions are true, we could leverage <em>strings</em> to get the text content, then filter it as needed with <em>grep</em>.</p>

<p>To understand the approach here, examine the following shell commands and outputs. In this example, we create an empty repo with two commits. Each commit adds a different file with a <code class="language-plaintext highlighter-rouge">.yaml</code> extension. Afterwards, we can dump all strings from the <code class="language-plaintext highlighter-rouge">index</code> binary, and optionally filter by <code class="language-plaintext highlighter-rouge">.yaml</code> patterns:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Create a test repo.
$ mkdir git-test
$ cd git-test
$ git init
Initialized empty Git repository in /.../git-test/.git/

# Create a dummy YAML file and commit it.
$ touch file-a.yaml
$ git add . 
$ git commit -m "initial commit"
[main (root-commit) b037146] initial commit
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 file-a.yaml
 
# Create another file and commit that too.
# Git HEAD will now point to this commit.
$ touch file-b.yaml
$ git add .
$ git commit -m "added a file"
[main 8a56a6d] added a file
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 file-b.yaml
 
# View the names of YAML files from this output.
$ strings .git/index | grep '.yaml'
file-a.yaml
file-b.yaml
</code></pre></div></div>

<p>As you can see, in a black-box engagement, this may prove a feasible way to achieve file enumeration from a simple path-traversal vulnerability. The Git specification makes no claims that entires should be encrypted. So, it is reasonable to assume that the secrets appear in cleartext.</p>

<p>As noted earlier, you can use <code class="language-plaintext highlighter-rouge">/nostromo</code> to get the contents of any file on the system. But I’m still interested in why the <code class="language-plaintext highlighter-rouge">/yaml</code> functionality exists, especially since the “Alien Loaders” description calls out its importance. To me, this implies that there is a YAML file in the project structure; and we’re going to use the <code class="language-plaintext highlighter-rouge">index</code> file contents to prove this one way or another.</p>

<p>First, fetch the file:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl -X POST \
	-H "Content-Type: application/json" \
	-H "Accept: application/octet-stream" \
	-d '{"file_path": "../.git/index"}' \
	-o index.bin \
	http://10.10.120.111/api/nostromo
</code></pre></div></div>

<p>Then, inspect the contents for <code class="language-plaintext highlighter-rouge">.yaml</code> files:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>strings index.bin | grep '.yaml'
...
public/100375.yaml
...
</code></pre></div></div>

<p>Indeed, this matches the same “control code” given in the CTF description.</p>

<p>Now, let’s try to enumerate <code class="language-plaintext highlighter-rouge">.txt</code> files:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>strings index.bin | grep '.txt'
...
mother/0rd3r937.txt
mother/secret.txt
...
public/0rd3rXXX.txt
...
</code></pre></div></div>

<p>Using this enumeration, we have revealed the contents of the following interesting files:</p>

<ul>
  <li><em>public/100375.yaml</em>, which contains a reference to <em>0rd3rXXX.txt</em>, and implies that the order number is XXX (redacted)</li>
  <li><em>public/0rd3rXXX.txt</em>, which contains the “Nostromo route” flag</li>
  <li><em>mother/0rd3rXXX.txt</em>, which reveals the order number</li>
  <li><em>mother/secret.txt</em>, which contains a reference to <em>/opt/m0th3r</em>, the location of the “Mother’s secret” flag</li>
</ul>

<p>By this point, we have four of the six flags, and have all but exhausted the server-side attack paths given the path-traversal vulnerability. For the final two, let’s inspect the client. As noted, the core frontend logic exists in <em>index.min.js</em>.</p>

<p>When testing minified JavaScript, it is always a good practice to use a “beautifier” or “unminifier” tool. These tools will not defeat all of the obfuscation or mangling techniques, but it will lay out the code in a way that’s easier to read and inspect.</p>

<p>With the unminified JS, try to identify key labels, such as variable or function names. Keeping the frontend behavior in mind, try to look for things that could reveal or authenticate the “hidden” content.</p>

<p>In this case, the following labels should stand out:</p>

<ul>
  <li><em>authYaml</em> and <em>authNostromo</em>, two variables which are initialized to <em>false</em></li>
  <li>yamlSocket and nostromoSocket, websocket instances which interact with <code class="language-plaintext highlighter-rouge">/yaml</code> and <code class="language-plaintext highlighter-rouge">/nostromo</code> websocket routes</li>
  <li><em>authWebSocket</em>, a function which uses these websockets and updates their “authentication” states programmatically, but reverts each <em>auth</em> variable to <em>false</em> in such a way that both variables are never <em>true</em> at the same time</li>
  <li><em>modifyData</em>, a function that executes only when <em>authYaml</em> and <em>authNostromo</em> are both <em>true</em> at the same time</li>
</ul>

<p>If you inspect the <em>modifyData</em> arrow function, notice the references to DOM manipulation (<em>querySelector</em>). This may control the state of hidden files in the client-side application.</p>

<p>Before probing too far, keep investigating the JS. Notice the massive array defined at <code class="language-plaintext highlighter-rouge">_0x491022</code>. You’ll notice, among other things, the entire frontend text content, along with some Base64 encoded data, one of which decodes the client-side flag. The scientist’s name is also there, and it should stand out if you watched the first <em>Alien</em>.</p>

<p>Before making assumptions, though, let’s go back to the authentication logic. <em>modifyData</em> is defined in the global scope. It is callable without any arguments or prerequisite conditions. This makes the need to manage <em>authYaml</em> and <em>authNostromo</em> moot, and therefore represents another case of broken access control. It also means that we could execute this in the console and it should execute successfully.</p>

<p>In a real engagement, you should be careful about how you report this issue. Executing script in the console is not, for example, a Cross-site Scripting finding. The root issue here is not the code, but rather, the <em>hardcoded secrets</em> in the client code. This attack will already prove what we learned from the array at <code class="language-plaintext highlighter-rouge">_0x491022</code>: that, likely, <em>modifyData</em> just reveals the cleartext data stored here.</p>

<p>In any case, open the Dev Tools and execute <code class="language-plaintext highlighter-rouge">modifyData()</code>. The HTML code now “reveals” the flag and scientist’s name. It does so by taking values from that array and printing them to the console.</p>

<h1 id="assessment">Assessment</h1>

<p>Overall, this report should focus on the following vulnerable coding patterns:</p>

<ul>
  <li>Hardcoded secrets in the web and source files</li>
  <li>Lack of identity controls (Authentication), which is necessarily a prerequisite for access control (Authorization)</li>
  <li>Injection attacks due to unsanitized input, which allows an attacker to traverse files on the system</li>
  <li>Excessive privileges in the deployed web application, which enables an attacker to traverse files in locations like <em>/etc</em>, and even in the root user’s folder</li>
  <li>Nonexistent access controls for the source repository, which enables an attacker to steal the entire source code</li>
  <li>Deployment of excessive configuration files, which enable an attacker to learn more about the project by merely reading those files</li>
</ul>

<p>Clearly, the frontend and backend developers mistake the secrecy of their business workflows as a proof of identity. They would benefit from hardening their CI/CD process, from using a SAST and Secrets scanner, and from implementing identity and access management.</p>

  </div><a class="u-url" href="/2024/02/18/thm-dso-walkthrough.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">halcyondream</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">halcyondream</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/halcyondream"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">halcyondream</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Portfolio for Cybersecurity projects, research, and developments.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
